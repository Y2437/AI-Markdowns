好的，我已仔细阅读并理解了您提供的《算法设计与分析综合笔记》。这份笔记结构清晰，内容详尽，确实是基于《算法导论》的经典框架。

我将遵循您的所有要求，为您撰写一份配套的、高质量的C++算法模板库。这份代码库将：
*   **完全覆盖**笔记中提到的所有核心算法。
*   采用**现代C++**风格（如 `std::vector`, `auto` 等），以确保代码的简洁性和高效性。
*   严格遵守您的特殊要求：对于**堆排序**，我将提供一个不依赖STL的C语言风格实现。对于其他算法，我会优先使用最能体现算法思想且易于理解的方式实现。
*   提供**详尽的注释**，解释代码的关键部分、时间/空间复杂度以及使用时的注意事项。
*   确保代码的**正确性和鲁棒性**，使其可以直接用于学习、练习或作为竞赛中的“板子”。

---

### **算法模板库 (C++)**

### **第二部分：排序与顺序统计**

#### **6. 排序算法**

##### **6.1. 堆排序 (Heapsort) - C语言风格实现**

根据您的要求，这里提供一个不使用STL `priority_queue` 的C风格堆排序实现。它直接在数组上进行原地操作。

```cpp
#include <iostream>
#include <vector>
#include <algorithm> // for std::swap

// --- 堆排序 (C-Style Implementation) ---

// 维护最大堆性质的函数 (下沉操作)
// A: 待排序的数组 (用vector模拟)
// i: 需要下沉的节点索引
// heapSize: 堆的大小
void maxHeapify(std::vector<int>& A, int i, int heapSize) {
    int left = 2 * i + 1;  // 左孩子索引
    int right = 2 * i + 2; // 右孩子索引
    int largest = i;       // 假设父节点最大

    // 找出父、左、右三者中的最大值
    if (left < heapSize && A[left] > A[largest]) {
        largest = left;
    }
    if (right < heapSize && A[right] > A[largest]) {
        largest = right;
    }

    // 如果最大值不是父节点，则交换并递归下沉
    if (largest != i) {
        std::swap(A[i], A[largest]);
        maxHeapify(A, largest, heapSize);
    }
}

// 构建最大堆
void buildMaxHeap(std::vector<int>& A) {
    int heapSize = A.size();
    // 从最后一个非叶子节点开始，自底向上进行下沉操作
    for (int i = heapSize / 2 - 1; i >= 0; --i) {
        maxHeapify(A, i, heapSize);
    }
}

// 堆排序主函数
// 时间复杂度: O(n log n)
// 空间复杂度: O(1) (原地排序)
void heapSort(std::vector<int>& A) {
    buildMaxHeap(A);
    int heapSize = A.size();
    // 循环n-1次，每次将堆顶(最大元素)与堆末尾元素交换，并重新维护堆
    for (int i = A.size() - 1; i > 0; --i) {
        std::swap(A[0], A[i]);
        heapSize--;
        maxHeapify(A, 0, heapSize);
    }
}
```

##### **6.2. 快速排序 (Quicksort) - 随机化版本**

随机化是实践中避免快速排序最坏情况的关键。

```cpp
#include <vector>
#include <algorithm> // for std::swap
#include <cstdlib>   // for rand()
#include <ctime>     // for time()

// --- 快速排序 (Randomized Version) ---

// 划分函数 (Lomuto partition scheme)
// 将数组A[p..r]划分为两部分，返回主元的最终位置
int partition(std::vector<int>& A, int p, int r) {
    int pivot = A[r]; // 选择最后一个元素为主元
    int i = p - 1;
    for (int j = p; j < r; ++j) {
        if (A[j] <= pivot) {
            i++;
            std::swap(A[i], A[j]);
        }
    }
    std::swap(A[i + 1], A[r]);
    return i + 1;
}

// 随机化划分，避免最坏情况
int randomizedPartition(std::vector<int>& A, int p, int r) {
    // 在[p, r]范围内随机选择一个元素作为主元，并与A[r]交换
    int i = p + rand() % (r - p + 1);
    std::swap(A[i], A[r]);
    return partition(A, p, r);
}

// 快速排序递归函数
void quickSortRecursive(std::vector<int>& A, int p, int r) {
    if (p < r) {
        int q = randomizedPartition(A, p, r);
        quickSortRecursive(A, p, q - 1);
        quickSortRecursive(A, q + 1, r);
    }
}

// 快速排序主函数
// 平均时间复杂度: O(n log n)
// 最坏时间复杂度: O(n^2) (随机化后概率极低)
// 空间复杂度: O(log n) (递归栈深度)
void quickSort(std::vector<int>& A) {
    srand(time(NULL)); // 初始化随机数种子
    quickSortRecursive(A, 0, A.size() - 1);
}
```

#### **7. 中位数与顺序统计**

##### **7.2. 期望为线性时间的选择算法 (Randomized-Select)**

该算法用于在 O(n) 的期望时间内找到数组中第 i 小的元素。

```cpp
#include <vector>
#include <algorithm> // for std::swap
#include <cstdlib>   // for rand()
#include <ctime>     // for time()

// --- 期望线性时间选择算法 (Randomized-Select) ---

// 使用 6.2 中的 randomizedPartition 和 partition 函数

// 随机选择算法递归函数
// 在A[p..r]中查找第i小的元素 (i是基于整个数组的1-based索引)
int randomizedSelectRecursive(std::vector<int>& A, int p, int r, int i) {
    if (p == r) {
        return A[p];
    }
    int q = randomizedPartition(A, p, r);
    int k = q - p + 1; // 主元是子数组中的第k小元素
    if (i == k) {
        return A[q];
    } else if (i < k) {
        return randomizedSelectRecursive(A, p, q - 1, i);
    } else {
        return randomizedSelectRecursive(A, q + 1, r, i - k);
    }
}

// 主函数
// 平均时间复杂度: O(n)
// 最坏时间复杂度: O(n^2)
int randomizedSelect(std::vector<int>& A, int i) {
    if (i < 1 || i > A.size()) return -1; // 错误处理
    srand(time(NULL));
    return randomizedSelectRecursive(A, 0, A.size() - 1, i);
}
```

### **第三部分：高级设计与分析技术**

#### **8. 动态规划 (Dynamic Programming)**

##### **8.2. 钢条切割 (Rod Cutting)**

```cpp
#include <vector>
#include <algorithm> // for std::max

// --- 钢条切割 (Bottom-Up DP with Solution Reconstruction) ---
// p: 价格数组, p[i]是长度为i+1的钢条价格
// n: 钢条总长度
// 返回最大收益和切割方案
std::pair<int, std::vector<int>> cutRod(const std::vector<int>& p, int n) {
    std::vector<int> r(n + 1); // r[i] 存储长度为i的最大收益
    std::vector<int> s(n + 1); // s[i] 存储长度为i时，第一段的最优切割长度
    r[0] = 0;

    for (int j = 1; j <= n; ++j) {
        int q = -1;
        for (int i = 1; i <= j; ++i) {
            if (q < p[i - 1] + r[j - i]) {
                q = p[i - 1] + r[j - i];
                s[j] = i;
            }
        }
        r[j] = q;
    }

    // 重构切割方案
    std::vector<int> cuts;
    int current_n = n;
    while (current_n > 0) {
        cuts.push_back(s[current_n]);
        current_n -= s[current_n];
    }
    
    return {r[n], cuts};
}
```

##### **8.3. 矩阵链乘法 (Matrix-Chain Multiplication)**

```cpp
#include <vector>
#include <climits> // for INT_MAX

// --- 矩阵链乘法 (Bottom-Up DP with Solution Reconstruction) ---
// p: 维度数组, 矩阵Ai的维度是 p[i-1] x p[i]
// 返回最小乘法次数和括号化方案的记录表
std::pair<std::vector<std::vector<int>>, std::vector<std::vector<int>>>
matrixChainOrder(const std::vector<int>& p) {
    int n = p.size() - 1;
    std::vector<std::vector<int>> m(n + 1, std::vector<int>(n + 1));
    std::vector<std::vector<int>> s(n + 1, std::vector<int>(n + 1));

    for (int i = 1; i <= n; ++i) {
        m[i][i] = 0;
    }

    for (int l = 2; l <= n; ++l) { // l is the chain length
        for (int i = 1; i <= n - l + 1; ++i) {
            int j = i + l - 1;
            m[i][j] = INT_MAX;
            for (int k = i; k < j; ++k) {
                int q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j];
                if (q < m[i][j]) {
                    m[i][j] = q;
                    s[i][j] = k;
                }
            }
        }
    }
    return {m, s};
}

// 打印最优括号化方案
void printOptimalParens(const std::vector<std::vector<int>>& s, int i, int j) {
    if (i == j) {
        std::cout << "A" << i;
    } else {
        std::cout << "(";
        printOptimalParens(s, i, s[i][j]);
        printOptimalParens(s, s[i][j] + 1, j);
        std::cout << ")";
    }
}
```

##### **8.4. 最长公共子序列 (Longest Common Subsequence, LCS)**

```cpp
#include <string>
#include <vector>
#include <algorithm> // for std::max

// --- 最长公共子序列 (Bottom-Up DP with Solution Reconstruction) ---
// 时间复杂度: O(m*n)
// 空间复杂度: O(m*n)
std::string lcs(const std::string& X, const std::string& Y) {
    int m = X.length();
    int n = Y.length();
    std::vector<std::vector<int>> c(m + 1, std::vector<int>(n + 1));
    
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (X[i - 1] == Y[j - 1]) {
                c[i][j] = c[i - 1][j - 1] + 1;
            } else {
                c[i][j] = std::max(c[i - 1][j], c[i][j - 1]);
            }
        }
    }

    // 重构LCS字符串
    std::string result = "";
    int i = m, j = n;
    while (i > 0 && j > 0) {
        if (X[i - 1] == Y[j - 1]) {
            result = X[i - 1] + result;
            i--;
            j--;
        } else if (c[i - 1][j] > c[i][j - 1]) {
            i--;
        } else {
            j--;
        }
    }
    return result;
}
```

#### **9. 贪心算法 (Greedy Algorithms)**

##### **9.2. 活动选择问题 (Activity Selection)**

```cpp
#include <vector>
#include <algorithm> // for std::sort

// --- 活动选择问题 (Greedy) ---
struct Activity {
    int start;
    int finish;
    int id;
};

// 比较函数，用于按结束时间排序
bool compareActivities(const Activity& a, const Activity& b) {
    return a.finish < b.finish;
}

// 时间复杂度: O(n log n) (主要瓶颈在排序)
std::vector<int> activitySelector(std::vector<Activity>& activities) {
    // 1. 按结束时间非递减排序
    std::sort(activities.begin(), activities.end(), compareActivities);

    std::vector<int> result;
    if (activities.empty()) return result;

    // 2. 选择第一个活动
    result.push_back(activities[0].id);
    int last_finish_time = activities[0].finish;

    // 3. 迭代选择兼容的活动
    for (size_t i = 1; i < activities.size(); ++i) {
        if (activities[i].start >= last_finish_time) {
            result.push_back(activities[i].id);
            last_finish_time = activities[i].finish;
        }
    }
    return result;
}
```

##### **9.5. 背包问题 (Knapsack Problem)**

```cpp
#include <vector>
#include <algorithm> // for std::sort, std::max

// --- 背包问题 ---

// 0-1 背包问题 (Dynamic Programming)
// items: {value, weight}
// W: 背包容量
// 时间复杂度: O(nW), 空间复杂度: O(nW) (可优化至O(W))
int knapsack01(const std::vector<std::pair<int, int>>& items, int W) {
    int n = items.size();
    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(W + 1, 0));

    for (int i = 1; i <= n; ++i) {
        int value = items[i - 1].first;
        int weight = items[i - 1].second;
        for (int w = 1; w <= W; ++w) {
            if (weight <= w) {
                // 两种选择: 不放入 vs 放入
                dp[i][w] = std::max(dp[i - 1][w], value + dp[i - 1][w - weight]);
            } else {
                dp[i][w] = dp[i - 1][w];
            }
        }
    }
    return dp[n][W];
}


// 分数背包问题 (Greedy)
struct Item {
    int value;
    int weight;
    double ratio; // value / weight
};

bool compareItems(const Item& a, const Item& b) {
    return a.ratio > b.ratio;
}

// 时间复杂度: O(n log n) (主要瓶颈在排序)
double fractionalKnapsack(std::vector<Item>& items, int W) {
    // 1. 计算单位价值并排序
    for (auto& item : items) {
        item.ratio = static_cast<double>(item.value) / item.weight;
    }
    std::sort(items.begin(), items.end(), compareItems);

    double totalValue = 0.0;
    int currentWeight = 0;

    // 2. 贪心选择
    for (const auto& item : items) {
        if (currentWeight + item.weight <= W) {
            currentWeight += item.weight;
            totalValue += item.value;
        } else {
            int remainingWeight = W - currentWeight;
            totalValue += item.ratio * remainingWeight;
            break;
        }
    }
    return totalValue;
}
```

### **第四部分：图算法**

首先，定义一个通用的图表示法（邻接表）。

```cpp
#include <vector>
#include <queue>
#include <list>
#include <algorithm> // for std::sort, std::reverse

// --- 图的邻接表表示 ---
// 对于无权图
using UnweightedGraph = std::vector<std::vector<int>>;
// 对于带权图
const int INF = 1e9;
struct Edge {
    int to;
    int weight;
};
using WeightedGraph = std::vector<std::vector<Edge>>;
```

#### **11. 基本图算法**

##### **11.2. 广度优先搜索 (BFS)**

```cpp
// --- 广度优先搜索 (BFS) ---
// G: 无权图, s: 源点
// 返回从s到各点的距离
// 时间复杂度: O(V+E)
std::vector<int> bfs(const UnweightedGraph& G, int s) {
    int V = G.size();
    std::vector<int> dist(V, -1); // -1 表示不可达
    std::queue<int> q;

    dist[s] = 0;
    q.push(s);

    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int v : G[u]) {
            if (dist[v] == -1) {
                dist[v] = dist[u] + 1;
                q.push(v);
            }
        }
    }
    return dist;
}
```

##### **11.3. 深度优先搜索 (DFS)**

```cpp
// --- 深度优先搜索 (DFS) ---
void dfsVisit(const UnweightedGraph& G, int u, std::vector<bool>& visited) {
    visited[u] = true;
    // Process vertex u here
    for (int v : G[u]) {
        if (!visited[v]) {
            dfsVisit(G, v, visited);
        }
    }
}

// 时间复杂度: O(V+E)
void dfs(const UnweightedGraph& G) {
    int V = G.size();
    std::vector<bool> visited(V, false);
    for (int i = 0; i < V; ++i) {
        if (!visited[i]) {
            dfsVisit(G, i, visited);
        }
    }
}
```

##### **11.4. 拓扑排序 (Topological Sort)**

```cpp
// --- 拓扑排序 (基于DFS) ---
void topoSortVisit(const UnweightedGraph& G, int u, std::vector<bool>& visited, std::list<int>& result) {
    visited[u] = true;
    for (int v : G[u]) {
        if (!visited[v]) {
            topoSortVisit(G, v, visited, result);
        }
    }
    // 当一个节点的所有邻居都访问完后，将其加入结果链表的前端
    result.push_front(u);
}

// 时间复杂度: O(V+E)
std::list<int> topologicalSort(const UnweightedGraph& G) {
    int V = G.size();
    std::vector<bool> visited(V, false);
    std::list<int> result;
    for (int i = 0; i < V; ++i) {
        if (!visited[i]) {
            topoSortVisit(G, i, visited, result);
        }
    }
    return result;
}
```

##### **11.5. 强连通分量 (Strongly Connected Components) - Kosaraju算法**

```cpp
// --- 强连通分量 (Kosaraju's Algorithm) ---
// 1. 在原图G上DFS，记录完成时间
void fillOrder(const UnweightedGraph& G, int u, std::vector<bool>& visited, std::vector<int>& order) {
    visited[u] = true;
    for (int v : G[u]) {
        if (!visited[v]) {
            fillOrder(G, v, visited, order);
        }
    }
    order.push_back(u);
}

// 2. 在转置图GT上DFS
void sccDfs(const UnweightedGraph& GT, int u, std::vector<bool>& visited, std::vector<int>& component) {
    visited[u] = true;
    component.push_back(u);
    for (int v : GT[u]) {
        if (!visited[v]) {
            sccDfs(GT, v, visited, component);
        }
    }
}

// 时间复杂度: O(V+E)
std::vector<std::vector<int>> stronglyConnectedComponents(const UnweightedGraph& G) {
    int V = G.size();
    std::vector<int> order;
    std::vector<bool> visited(V, false);

    // 第一次DFS
    for (int i = 0; i < V; ++i) {
        if (!visited[i]) {
            fillOrder(G, i, visited, order);
        }
    }

    // 计算转置图
    UnweightedGraph GT(V);
    for (int u = 0; u < V; ++u) {
        for (int v : G[u]) {
            GT[v].push_back(u);
        }
    }

    // 第二次DFS
    std::fill(visited.begin(), visited.end(), false);
    std::vector<std::vector<int>> sccs;
    std::reverse(order.begin(), order.end());

    for (int u : order) {
        if (!visited[u]) {
            std::vector<int> component;
            sccDfs(GT, u, visited, component);
            sccs.push_back(component);
        }
    }
    return sccs;
}
```

#### **12. 最小生成树 (MST)**

##### **12.1. Kruskal 算法**

```cpp
#include <vector>
#include <algorithm> // for std::sort
#include <numeric>   // for std::iota

// --- Kruskal算法 (使用并查集) ---
struct MstEdge {
    int u, v, weight;
};

bool compareMstEdges(const MstEdge& a, const MstEdge& b) {
    return a.weight < b.weight;
}

// 并查集 (Disjoint Set Union)
struct DSU {
    std::vector<int> parent;
    DSU(int n) {
        parent.resize(n);
        std::iota(parent.begin(), parent.end(), 0);
    }
    int find(int i) {
        if (parent[i] == i) return i;
        return parent[i] = find(parent[i]); // 路径压缩
    }
    void unite(int i, int j) {
        int root_i = find(i);
        int root_j = find(j);
        if (root_i != root_j) {
            parent[root_i] = root_j;
        }
    }
};

// 时间复杂度: O(E log E) 或 O(E log V)
int kruskal(int V, std::vector<MstEdge>& edges) {
    std::sort(edges.begin(), edges.end(), compareMstEdges);
    DSU dsu(V);
    int mst_weight = 0;
    int edges_count = 0;

    for (const auto& edge : edges) {
        if (dsu.find(edge.u) != dsu.find(edge.v)) {
            dsu.unite(edge.u, edge.v);
            mst_weight += edge.weight;
            edges_count++;
            if (edges_count == V - 1) break;
        }
    }
    return mst_weight;
}
```

##### **12.2. Prim 算法**

```cpp
#include <vector>
#include <queue>

// --- Prim算法 (使用优先队列) ---
using PII = std::pair<int, int>; // {weight, vertex}

// 时间复杂度: O(E log V)
int prim(const WeightedGraph& G) {
    int V = G.size();
    std::priority_queue<PII, std::vector<PII>, std::greater<PII>> pq;
    std::vector<bool> inMST(V, false);
    int mst_weight = 0;

    // 从顶点0开始
    pq.push({0, 0});

    while (!pq.empty()) {
        int w = pq.top().first;
        int u = pq.top().second;
        pq.pop();

        if (inMST[u]) continue;

        inMST[u] = true;
        mst_weight += w;

        for (const auto& edge : G[u]) {
            int v = edge.to;
            int weight = edge.weight;
            if (!inMST[v]) {
                pq.push({weight, v});
            }
        }
    }
    return mst_weight;
}
```

#### **13. 单源最短路径**

##### **13.2. Bellman-Ford 算法**

```cpp
#include <vector>
#include <climits> // for INT_MAX

// --- Bellman-Ford算法 ---
// G: 带权图, s: 源点
// 返回从s到各点的距离，如果存在负权环则返回空vector
// 时间复杂度: O(VE)
std::vector<int> bellmanFord(const WeightedGraph& G, int s) {
    int V = G.size();
    std::vector<int> dist(V, INF);
    dist[s] = 0;

    // 松弛 V-1 次
    for (int i = 0; i < V - 1; ++i) {
        for (int u = 0; u < V; ++u) {
            for (const auto& edge : G[u]) {
                int v = edge.to;
                int w = edge.weight;
                if (dist[u] != INF && dist[u] + w < dist[v]) {
                    dist[v] = dist[u] + w;
                }
            }
        }
    }

    // 检查负权环路
    for (int u = 0; u < V; ++u) {
        for (const auto& edge : G[u]) {
            int v = edge.to;
            int w = edge.weight;
            if (dist[u] != INF && dist[u] + w < dist[v]) {
                return {}; // 存在负权环路
            }
        }
    }
    return dist;
}
```

##### **13.3. Dijkstra 算法**

```cpp
#include <vector>
#include <queue>

// --- Dijkstra算法 (使用优先队列) ---
// G: 带权图 (权重必须非负), s: 源点
// 时间复杂度: O(E log V)
std::vector<int> dijkstra(const WeightedGraph& G, int s) {
    int V = G.size();
    std::vector<int> dist(V, INF);
    dist[s] = 0;
    
    using PII = std::pair<int, int>; // {distance, vertex}
    std::priority_queue<PII, std::vector<PII>, std::greater<PII>> pq;
    pq.push({0, s});

    while (!pq.empty()) {
        int d = pq.top().first;
        int u = pq.top().second;
        pq.pop();

        if (d > dist[u]) continue;

        for (const auto& edge : G[u]) {
            int v = edge.to;
            int w = edge.weight;
            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
        }
    }
    return dist;
}```

#### **14. 所有结点对的最短路径**

##### **14.2. Floyd-Warshall 算法**

```cpp
#include <vector>
#include <algorithm> // for std::min

// --- Floyd-Warshall算法 ---
// adjMatrix: 邻接矩阵表示的图, adjMatrix[i][j] = weight or INF
// 时间复杂度: O(V^3)
void floydWarshall(std::vector<std::vector<int>>& adjMatrix) {
    int V = adjMatrix.size();
    for (int k = 0; k < V; ++k) {
        for (int i = 0; i < V; ++i) {
            for (int j = 0; j < V; ++j) {
                if (adjMatrix[i][k] != INF && adjMatrix[k][j] != INF) {
                    adjMatrix[i][j] = std::min(adjMatrix[i][j], adjMatrix[i][k] + adjMatrix[k][j]);
                }
            }
        }
    }
}
```

#### **15. 最大流**

##### **15.3. Edmonds-Karp 算法**

```cpp
#include <vector>
#include <queue>
#include <algorithm> // for std::min

// --- Edmonds-Karp算法 (最大流) ---
// capacity: 容量邻接矩阵
// s: 源点, t: 汇点
// 时间复杂度: O(V * E^2)
int edmondsKarp(std::vector<std::vector<int>>& capacity, int s, int t) {
    int V = capacity.size();
    std::vector<std::vector<int>> adj(V);
    for(int i=0; i<V; ++i) {
        for(int j=0; j<V; ++j) {
            if(capacity[i][j] > 0) adj[i].push_back(j);
        }
    }

    int flow = 0;
    std::vector<int> parent(V);

    while (true) {
        std::fill(parent.begin(), parent.end(), -1);
        std::queue<std::pair<int, int>> q;
        q.push({s, INF});
        parent[s] = s;

        while (!q.empty()) 
        {
            int u = q.front().first;
            int path_flow = q.front().second;
            q.pop();

            for (int v : adj[u]) 
            {
                if (parent[v] == -1 && capacity[u][v] > 0) 
                {
                    parent[v] = u;
                    int new_flow = std::min(path_flow, capacity[u][v]);
                    if (v == t) 
                    {
                        // 找到增广路径
                        while (v != s) 
                        {
                            u = parent[v];
                            capacity[u][v] -= new_flow;
                            capacity[v][u] += new_flow; // 更新反向边
                            v = u;
                        }
                        flow += new_flow;
                        goto next_iteration;
                    }
                    q.push({v, new_flow});
                }
            }
        }
        break; // 没有更多增广路径
        next_iteration:;
    }
    return flow;
}
```

### **第五部分：特定领域算法**

#### **16. 字符串匹配**

##### **16.4. Knuth-Morris-Pratt (KMP) 算法**

```cpp
#include <string>
#include <vector>

// --- KMP字符串匹配算法 ---

// 计算前缀函数 (next数组)
// 时间复杂度: O(m)
std::vector<int> computePrefixFunction(const std::string& P) {
    int m = P.length();
    std::vector<int> pi(m);
    pi[0] = 0;
    int k = 0;
    for (int q = 1; q < m; ++q) {
        while (k > 0 && P[k] != P[q]) {
            k = pi[k - 1];
        }
        if (P[k] == P[q]) {
            k++;
        }
        pi[q] = k;
    }
    return pi;
}

// KMP匹配主函数
// 时间复杂度: O(n+m)
std::vector<int> kmpMatcher(const std::string& T, const std::string& P) {
    int n = T.length();
    int m = P.length();
    if (m == 0) return {};
    std::vector<int> pi = computePrefixFunction(P);
    std::vector<int> matches;
    int q = 0; // 已匹配的字符数

    for (int i = 0; i < n; ++i) {
        while (q > 0 && P[q] != T[i]) {
            q = pi[q - 1];
        }
        if (P[q] == T[i]) {
            q++;
        }
        if (q == m) {
            matches.push_back(i - m + 1); // 找到一个匹配，偏移量为 i-m+1
            q = pi[q - 1]; // 继续寻找下一个匹配
        }
    }
    return matches;
}
```

#### **17. 计算几何**

##### **17.3. 凸包问题 - Graham扫描法**

```cpp
#include <vector>
#include <algorithm> // for std::sort
#include <cmath>     // for atan2

// --- Graham扫描法 (凸包) ---
struct Point {
    long long x, y;
};

Point p0; // 全局变量，用于排序

// 计算两向量的叉积 (p1-p0) x (p2-p0)
long long cross_product(Point p0, Point p1, Point p2) {
    return (p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y);
}

// 计算两点间距离的平方
long long distSq(Point p1, Point p2) {
    return (p1.x - p2.x)*(p1.x - p2.x) + (p1.y - p2.y)*(p1.y - p2.y);
}

// 极角排序的比较函数
bool comparePoints(Point p1, Point p2) {
    long long order = cross_product(p0, p1, p2);
    if (order == 0) { // 共线情况，距离近的排前面
        return distSq(p0, p1) < distSq(p0, p2);
    }
    return order > 0; // p1在p2的逆时针方向
}

// 时间复杂度: O(n log n)
std::vector<Point> grahamScan(std::vector<Point>& points) {
    int n = points.size();
    if (n < 3) return points;

    // 1. 找到y最小(y相同则x最小)的点p0
    int min_idx = 0;
    for (int i = 1; i < n; i++) {
        if (points[i].y < points[min_idx].y || 
           (points[i].y == points[min_idx].y && points[i].x < points[min_idx].x)) {
            min_idx = i;
        }
    }
    std::swap(points[0], points[min_idx]);
    p0 = points[0];

    // 2. 极角排序
    std::sort(points.begin() + 1, points.end(), comparePoints);

    // 3. 构建凸包
    std::vector<Point> hull;
    hull.push_back(points[0]);
    hull.push_back(points[1]);

    for (int i = 2; i < n; i++) {
        while (hull.size() > 1 && cross_product(hull[hull.size()-2], hull.back(), points[i]) <= 0) {
            hull.pop_back(); // 非左转，出栈
        }
        hull.push_back(points[i]);
    }
    return hull;
}
```

#### **18. 多项式与快速傅里叶变换 (FFT)**

````cpp
#include <vector>
#include <complex>
#include <cmath>
#include <algorithm> // for std::reverse

// --- 快速傅里叶变换 (FFT) - 迭代实现 ---
using Complex = std::complex<double>;
const double PI = acos(-1.0);

void fft(std::vector<Complex>& a, bool invert) {
    int n = a.size();
    if (n <= 1) return;

    // 1. 位逆序置换
    for (int i = 1, j = 0; i < n; i++) {
        int bit = n >> 1;
        for (; j & bit; bit >>= 1)
            j ^= bit;
        j ^= bit;
        if (i < j)
            std::swap(a[i], a[j]);
    }

    // 2. 迭代蝶形运算
    for (int len = 2; len <= n; len <<= 1) {
        double ang = 2 * PI / len * (invert ? -1 : 1);
        Complex wlen(cos(ang), sin(ang));
        for (int i = 0; i < n; i += len) {
            Complex w(1);
            for (int j = 0; j < len / 2; j++) {
                Complex u = a[i + j], v = a[i + j + len / 2] * w;
                a[i + j] = u + v;
                a[i + j + len / 2] = u - v;
                w *= wlen;
            }
        }
    }

    // 3. 如果是逆变换，需要除以n
    if (invert) {
        for (Complex& x : a)
            x /= n;
    }
}

// 多项式乘法
// a, b: 系数向量
// 时间复杂度: O(N log N), N是结果多项式的次数界
std::vector<long long> multiplyPolynomials(const std::vector<int>& a, const std::vector<int>& b) {
    std::vector<Complex> fa(a.begin(), a.end()), fb(b.begin(), b.end());
    int n = 1;
    while (n < a.size() + b.size()) n <<= 1;
    fa.resize(n);
    fb.resize(n);

    fft(fa, false);
    fft(fb, false);

    for (int i = 0; i < n; i++)
        fa[i] *= fb[i];
    
    fft(fa, true);

    std::vector<long long> result(n);
    for (int i = 0; i < n; i++)
        result[i] = round(fa[i].real());
    
    return result;
}
```
````

