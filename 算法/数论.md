# 数论核心算法C++笔记：从基础到应用

## 总序
本文档系统整理数论中8个核心算法：**欧几里得算法**（求最大公约数）、**贝祖定理**（线性组合表示）、**拓展欧几里得算法**（求贝祖系数）、**快速幂**（高效幂运算）、**费马小定理**（质数模下幂性质）、**乘法逆元**（模运算逆元求解）、**模线性方程**（$ax≡c \mod m$求解）、**中国余数定理**（多同余方程合并）。内容按"基础→工具→应用"逻辑展开，每个算法包含**核心原理**（详细推导）、**算法步骤**、**实例演示**、**C++函数实现**，形成完整知识链。

## 1. 欧几里得算法（Euclidean Algorithm）
### 核心原理
欧几里得算法（辗转相除法）是求两个整数最大公约数（gcd）的基础算法，核心结论：  
对任意整数$a, b$（$b≠0$），做带余除法$a = q·b + r$（$0≤r<|b|$，$q$为商，$r$为余数），则$\gcd(a,b) = \gcd(b,r)$。  

**证明**（基于公因数传递性）：  
- 设$d = \gcd(a,b)$，则$d∣a$且$d∣b$。由$r = a - q·b$，根据"若$d∣m$且$d∣n$，则$d∣(m - q·n)$"，得$d∣r$，故$d$是$b$和$r$的公因数，因此$d ≤ \gcd(b,r)$。  
- 设$d' = \gcd(b,r)$，则$d'∣b$且$d'∣r$。由$a = q·b + r$，同理得$d'∣a$，故$d'$是$a$和$b$的公因数，因此$d' ≤ \gcd(a,b)$。  
- 结合$d ≤ d'$和$d' ≤ d$，得$d = d'$，即$\gcd(a,b) = \gcd(b,r)$。  

重复带余除法，直到$r=0$，此时$\gcd(\text{非零数}, 0) = \text{非零数}$（因任何数是0的因数），算法终止。

### 算法步骤
1. 若$b=0$，返回$a$（此时$\gcd(a,0)=|a|$，默认$a≥0$）；  
2. 否则，计算$r = a \% b$，递归或迭代计算$\gcd(b, r)$；  
3. 返回最终结果。

### 实例演示
求$\gcd(252, 198)$：  
- 252 = 198×1 + 54 → gcd(198, 54)  
- 198 = 54×3 + 36 → gcd(54, 36)  
- 54 = 36×1 + 18 → gcd(36, 18)  
- 36 = 18×2 + 0 → 终止，返回18  
结果：$\gcd(252,198)=18$

### C++函数实现
```C++
// 递归版
long long gcd_rec(long long a, long long b) {
    return b == 0 ? a : gcd_rec(b, a % b);
}

// 迭代版（避免递归栈溢出，适合大数）
long long gcd_iter(long long a, long long b) {
    while (b != 0) {
        long long temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}
```

## 2. 贝祖定理（Bezout's Identity）
### 核心原理
贝祖定理是连接"最大公约数"与"线性组合"的关键定理：  
**对任意整数$a, b$，存在整数$s, t$，使得$a·s + b·t = \gcd(a,b)$**。  
该式称为"贝祖等式"，$s, t$称为"贝祖系数"（不唯一）。  

**证明**（构造性证明，基于欧几里得算法逆向回代）：  
- 基础情况：若$b=0$，则$\gcd(a,0)=a$，取$s=1, t=0$，满足$a·1 + 0·0 = a$。  
- 递归情况：若$b≠0$，做带余除法$a = q·b + r$（$0≤r<b$），由欧几里得算法知$\gcd(a,b)=\gcd(b,r)$。  
  假设对$b, r$存在贝祖系数$s', t'$，使得$b·s' + r·t' = \gcd(b,r)$。  
  将$r = a - q·b$代入上式：  
  $b·s' + (a - q·b)·t' = a·t' + b·(s' - q·t') = \gcd(a,b)$。  
  取$s = t'$，$t = s' - q·t'$，则$a·s + b·t = \gcd(a,b)$，得证。

### 关键推论
若$d = \gcd(a,b)$，则$a, b$的所有整系数线性组合都是$d$的倍数；反之，$d$的所有倍数都可表示为$a, b$的整系数线性组合。

### 实例演示
求$\gcd(252,198)=18$的贝祖系数：  
- 逆向回代欧几里得步骤：  
  18 = 54 - 36×1（由54=36×1+18）  
  36 = 198 - 54×3 → 18 = 54 - (198 - 54×3)×1 = 54×4 - 198×1  
  54 = 252 - 198×1 → 18 = (252 - 198×1)×4 - 198×1 = 252×4 - 198×5  
- 贝祖系数：$s=4, t=-5$，满足$252×4 + 198×(-5) = 18$。

## 3. 拓展欧几里得算法（Extended Euclidean Algorithm）
### 核心原理
拓展欧几里得算法是欧几里得算法的延伸，**不仅求$\gcd(a,b)$，还构造贝祖系数$s, t$满足$a·s + b·t = \gcd(a,b)$**。  

核心逻辑：  
1. 正向执行欧几里得算法，通过带余除法将$\gcd(a,b)$归约为$\gcd(d,0)=d$；  
2. 逆向回代每一步的余数表达式，将$d$逐步表示为前一步被除数和除数的线性组合，最终得到$a, b$的贝祖系数。

### 算法步骤（递归版）
1. 终止条件：若$b=0$，返回$\gcd=a$，并设置$s=1, t=0$；  
2. 递归调用：对$(b, a\%b)$调用拓展欧几里得，得到$\gcd$及系数$s1, t1$（满足$b·s1 + (a\%b)·t1 = \gcd$）；  
3. 逆向回代：由$a\%b = a - (a//b)·b$，代入得：  
   $b·s1 + (a - (a//b)·b)·t1 = a·t1 + b·(s1 - (a//b)·t1) = \gcd$；  
4. 设置当前系数$s = t1$，$t = s1 - (a//b)·t1$，返回$\gcd, s, t$。

### 实例演示
求$a=105, b=45$的$\gcd$及贝祖系数：  
- 正向欧几里得步骤：  
  105 = 45×2 + 15 → gcd(45,15)  
  45 = 15×3 + 0 → 终止，gcd=15  
- 逆向回代：  
  递归到$(15,0)$：返回$\gcd=15, s1=1, t1=0$；  
  回代到$(45,15)$：$q=45//15=3$，$s=0, t=1-3×0=1$（满足$45×0 +15×1=15$）；  
  回代到$(105,45)$：$q=105//45=2$，$s=1, t=0-2×1=-2$（满足$105×1 +45×(-2)=15$）；  
结果：$\gcd=15, s=1, t=-2$。

### C++函数实现
```C++
// 递归版：返回gcd，通过引用返回s, t
long long ext_gcd_rec(long long a, long long b, long long &s, long long &t) {
    if (b == 0) {
        s = 1;
        t = 0;
        return a;
    }
    long long gcd = ext_gcd_rec(b, a % b, s, t);
    long long temp = s;
    s = t;
    t = temp - (a / b) * t;
    return gcd;
}

// 迭代版：返回gcd，通过引用返回s, t（更稳定，适合大数）
long long ext_gcd_iter(long long a, long long b, long long &s, long long &t) {
    long long old_gcd = a, gcd = b;
    long long old_s = 1, s = 0;
    long long old_t = 0, t = 1;
    while (gcd != 0) {
        long long q = old_gcd / gcd;
        long long temp_gcd = gcd;
        gcd = old_gcd - q * gcd;
        old_gcd = temp_gcd;
        
        long long temp_s = s;
        s = old_s - q * s;
        old_s = temp_s;
        
        long long temp_t = t;
        t = old_t - q * t;
        old_t = temp_t;
    }
    s = old_s;
    t = old_t;
    return old_gcd;
}
```

## 4. 快速幂（Fast Exponentiation）
### 核心原理
快速幂（二分幂）是高效计算$a^n \mod m$的算法，时间复杂度从暴力的$O(n)$降至$O(\log n)$。核心思想：**将指数$n$按二进制拆分，利用幂的乘法性质$a^{2k} = (a^k)^2$、$a^{2k+1} = a^{2k}·a$实现二分计算**。  

例如：$a^5 = a^{4+1} = (a^2)^2 · a$，仅需3次乘法（而非5次）。

### 算法步骤
1. 初始化结果$res = 1$，将底数$a$对$m$取模（避免溢出）；  
2. 当$n > 0$时：  
   - 若$n$为奇数，$res = (res · a) \mod m$（乘当前底数）；  
   - 将$a = (a · a) \mod m$（底数平方），$n = n >> 1$（指数右移1位，即除以2）；  
3. 返回$res$。

### 实例演示
计算$3^5 \mod 7$：  
- 初始化$res=1, a=3, n=5, m=7$；  
- $n=5$（奇）：$res=(1×3)\mod7=3$，$a=(3×3)\mod7=2$，$n=2$；  
- $n=2$（偶）：$a=(2×2)\mod7=4$，$n=1$；  
- $n=1$（奇）：$res=(3×4)\mod7=12\mod7=5$，$a=(4×4)\mod7=2$，$n=0$；  
结果：$3^5 \mod7=5$。

### C++函数实现
```C++
// 计算 (a^n) mod m，支持a,n为非负整数，m>0
long long fast_pow(long long a, long long n, long long m) {
    long long res = 1;
    a = a % m;
    while (n > 0) {
        if (n % 2 == 1) {
            res = (res * a) % m;
        }
        a = (a * a) % m;
        n = n / 2;
    }
    return res;
}
```

## 5. 费马小定理（Fermat's Little Theorem）
### 核心原理
费马小定理是质数模下的重要幂性质：**若$p$为质数，且$a$与$p$互质（$\gcd(a,p)=1$），则$a^{p-1} ≡ 1 \mod p$**。  

**证明**（基于剩余系）：  
- 因$a$与$p$互质，集合$\{a·1, a·2, ..., a·(p-1)\}$模$p$的余数是$\{1, 2, ..., p-1\}$的一个排列（无重复，且均非0）；  
- 两边相乘：$a^{p-1} · (p-1)! ≡ (p-1)! \mod p$；  
- 因$(p-1)!$与$p$互质（$p$是质数），两边同乘$(p-1)!$的逆元，得$a^{p-1} ≡ 1 \mod p$。

### 关键应用：质数模下求乘法逆元
若$p$为质数且$\gcd(a,p)=1$，由费马小定理$a^{p-1} ≡ 1 \mod p$，拆分得$a · a^{p-2} ≡ 1 \mod p$。因此，**$a$在模$p$下的逆元为$a^{p-2} \mod p$**（可通过快速幂计算）。

### 实例演示
求$a=7$在模$p=10$（非质数，不可用）和$p=11$（质数）下的逆元：  
- 模$11$：$p-2=9$，计算$7^9 \mod11$；  
  7^2=49≡5，7^4=(5)^2=25≡3，7^8=(3)^2=9；  
  7^9=7^8×7=9×7=63≡8 mod11；  
- 验证：$7×8=56≡1 \mod11$，逆元为8。

### C++函数实现（费马小定理求逆元）
```C++
// 费马小定理求逆元：p必须是质数，且gcd(a,p)=1，否则返回-1（无效）
long long fermat_inv(long long a, long long p) {
    if (gcd_iter(a, p) != 1) {
        return -1;
    }
    return fast_pow(a, p - 2, p);
}
```

## 6. 乘法逆元（Modular Inverse）
### 核心定义
若整数$a$与模$m$互质（$\gcd(a,m)=1$），则存在唯一整数$x$使得$a·x ≡ 1 \mod m$，$x$称为$a$在模$m$下的乘法逆元，记为$a^{-1} \mod m$。

### 两种求解方法对比
| 对比维度       | 拓展欧几里得算法                | 费马小定理                      |
|----------------|---------------------------------|---------------------------------|
| 适用条件       | $\gcd(a,m)=1$（$m$任意）         | $\gcd(a,m)=1$且$m$为质数         |
| 核心原理       | 贝祖等式$a·x + m·y = 1$         | 质数模幂性质$a^{m-2}≡a^{-1}\mod m$ |
| 计算关键       | 逆向回代求$x$                   | 快速幂计算$a^{m-2}\mod m$        |
| 通用性         | 通用（推荐）                    | 仅质数模                        |

### 实例演示
求$a=7$在模$m=10$下的逆元（$\gcd(7,10)=1$）：  
- 拓展欧几里得法：解$7x +10y=1$；  
  10=7×1+3 → 7=3×2+1 → 1=7-3×2=7-(10-7×1)×2=7×3+10×(-2)；  
  $x=3$，验证$7×3=21≡1 \mod10$，逆元为3。  
- 费马小定理：$m=10$非质数，不可用。

### C++函数实现（两种方法）
```C++
// 拓展欧几里得求逆元：gcd(a,m)=1时返回逆元，否则返回-1
long long ext_gcd_inv(long long a, long long m) {
    long long s, t;
    long long d = ext_gcd_iter(a, m, s, t);
    if (d != 1) {
        return -1;
    }
    return (s % m + m) % m; // 调整为正逆元
}

// 统一接口：优先用拓展欧几里得（通用），m为质数时可用费马
long long mod_inv(long long a, long long m) {
    if (gcd_iter(a, m) != 1) {
        return -1;
    }
    // 若m为质数，可切换为fermat_inv(a,m)，此处默认用拓展欧几里得
    long long s, t;
    ext_gcd_iter(a, m, s, t);
    return (s % m + m) % m;
}
```

## 7. 模线性方程（Modular Linear Equation）
### 核心定义
模线性方程的一般形式：$a·x ≡ c \mod m$（$a,c,m$为整数，$m>0$），等价于"存在整数$k$使得$a·x - c = k·m$"，即线性丢番图方程$a·x + m·y = c$（$y=-k$）。

### 核心原理（解的存在性与求解逻辑）
1. **解的存在性**：方程有解的充要条件是$d∣c$，其中$d = \gcd(a,m)$；  
2. **简化方程**：若有解，将$a,c,m$同除以$d$，得$a'x ≡ c' \mod m'$（$a'=a/d, c'=c/d, m'=m/d$），此时$\gcd(a',m')=1$（互质）；  
3. **求逆元**：因$a'$与$m'$互质，求$a'$的逆元$x0$（满足$a'x0 ≡1 \mod m'$）；  
4. **特解**：简化方程的特解为$x1 = (c' · x0) \mod m'$；  
5. **通解**：原方程的所有解为$x = x1 + k·m'$（$k∈Z$），模$m$下共有$d$个不同解（$k=0,1,...,d-1$）。

### 实例演示
解方程$6x ≡12 \mod18$：  
1. 计算$d = \gcd(6,18)=6$，$c=12$，$6∣12$，有解；  
2. 简化方程：$a'=1, c'=2, m'=3$，方程变为$x≡2 \mod3$；  
3. 求逆元：$a'=1$的逆元为1（$1×1≡1 \mod3$）；  
4. 特解：$x1=(2×1)\mod3=2$；  
5. 通解：$x=2+3k$，模18下的解为$2,5,8,11,14,17$（共6个，与$d=6$一致）。

### C++函数实现
```C++
// 解模线性方程ax ≡ c mod m：返回是否有解，通过引用返回特解x0和周期m'
bool solve_linear_mod(long long a, long long c, long long m, long long &x0, long long &m_prime) {
    long long d = gcd_iter(a, m);
    if (c % d != 0) {
        return false; // 无解
    }
    // 简化方程
    long long a_prime = a / d;
    long long c_prime = c / d;
    m_prime = m / d;
    // 求a'的逆元
    long long inv_a, t;
    ext_gcd_iter(a_prime, m_prime, inv_a, t);
    inv_a = (inv_a % m_prime + m_prime) % m_prime;
    // 特解
    x0 = (c_prime * inv_a) % m_prime;
    return true;
}
```

## 8. 中国余数定理（Chinese Remainder Theorem, CRT）
### 核心定义（标准情况）
针对**两两互质模**的线性同余方程组：  
$$
\begin{cases}
x ≡ a_1 \mod m_1 \\
x ≡ a_2 \mod m_2 \\
\vdots \\
x ≡ a_n \mod m_n
\end{cases}
$$  
其中$m_1,m_2,...,m_n$两两互质（$\gcd(m_i,m_j)=1$，$i≠j$），则：  
- 方程组必有解；  
- 解在模$M = m_1×m_2×...×m_n$下唯一（存在$0≤x0<M$满足所有方程）。

### 核心原理（构造解）
1. **总模$M$**：所有模的乘积，约束解的唯一性范围；  
2. **部分模$M_i$**：$M_i = M / m_i$（总模除以第$i$个模），性质：$M_i$与$m_i$互质；  
3. **逆元$t_i$**：$M_i$在模$m_i$下的逆元（满足$M_i·t_i ≡1 \mod m_i$）；  
4. **构造解**：$x = (a_1M_1t_1 + a_2M_2t_2 + ... + a_nM_nt_n) \mod M$。  

**构造原理**：对第$i$个方程，$a_iM_iT_i ≡a_i×1=a_i \mod m_i$，其他项$a_jM_jT_j ≡0 \mod m_i$（因$M_j$含$m_i$因子），故$x$满足所有方程。

### 非标准情况（模不互质）
若模不两两互质，需先合并方程组：  
1. 取前两个方程$x≡a_1 \mod m_1$和$x≡a2 \mod m_2$，设$x=a1 + k·m1$；  
2. 代入第二个方程得$m1·k ≡ (a2 -a1) \mod m2$，用"模线性方程"判断解的存在性（$\gcd(m1,m2)∣(a2-a1)$）；  
3. 若有解，求$k$的通解，代入$x=a1 +k·m1$得合并后的方程$x≡x0 \mod M$（$M=\text{lcm}(m_1,m_2)=m_1m_2/\gcd(m_1,m_2)$）；  
4. 重复合并，直到得到单一方程，即为方程组的解。

### 实例演示（标准情况：物不知数问题）
求解：  
$$
\begin{cases}
x≡2 \mod3 \\
x≡3 \mod5 \\
x≡2 \mod7
\end{cases}
$$  
1. 总模$M=3×5×7=105$；  
2. 部分模：$M_1=35, M_2=21, M_3=15$；  
3. 逆元：$t_1=2$（35×2≡1 mod3），$t_2=1$（21×1≡1 mod5），$t_3=1$（15×1≡1 mod7）；  
4. 构造解：$x=(2×35×2 +3×21×1 +2×15×1)\mod105=(140+63+30)\mod105=23$；  
5. 验证：23 mod3=2，23 mod5=3，23 mod7=2，正确。

### C++函数实现
```C++
// 合并两个同余方程x≡a1 mod m1和x≡a2 mod m2：返回是否有解，通过引用返回合并后的(a,m)
bool merge_crt(long long a1, long long m1, long long a2, long long m2, long long &a, long long &m) {
    long long x0, m_prime;
    // 解m1*k ≡ (a2 -a1) mod m2
    if (!solve_linear_mod(m1, (a2 - a1 + m2) % m2, m2, x0, m_prime)) {
        return false;
    }
    // 合并后的解：x = a1 + x0*m1 mod lcm(m1,m2)
    m = m1 / gcd_iter(m1, m2) * m2; // lcm(m1,m2)
    a = (a1 + x0 * m1) % m;
    if (a < 0) a += m;
    return true;
}

// 标准CRT（模两两互质）：返回是否有解，通过引用返回解x0和总模M
bool crt_standard(const long long a[], const long long m[], int n, long long &x0, long long &M) {
    x0 = 0;
    M = 1;
    for (int i = 0; i < n; ++i) {
        long long Mi = M;
        M *= m[i];
        long long ti, t;
        ext_gcd_iter(Mi, m[i], ti, t);
        ti = (ti % m[i] + m[i]) % m[i];
        x0 = (x0 + a[i] * Mi % M * ti % M) % M;
    }
    return true;
}

// 通用CRT（模可互质或不互质）：返回是否有解，通过引用返回解x0和总模M
bool crt_general(const long long a[], const long long m[], int n, long long &x0, long long &M) {
    x0 = a[0];
    M = m[0];
    for (int i = 1; i < n; ++i) {
        if (!merge_crt(x0, M, a[i], m[i], x0, M)) {
            return false;
        }
    }
    return true;
}
```

## 总结：数论算法知识链
1. **基础工具**：欧几里得算法（求gcd）→ 贝祖定理（线性组合存在性）→ 拓展欧几里得算法（构造贝祖系数）；  
2. **幂运算优化**：快速幂（高效计算$a^n \mod m$）→ 费马小定理（质数模下幂性质，求逆元）；  
3. **核心应用**：乘法逆元（拓展欧几里得/费马）→ 模线性方程（$ax≡c \mod m$求解）→ 中国余数定理（多同余方程合并）。  

这些算法是密码学（RSA、ElGamal）、大整数计算、算法竞赛的核心基础，需重点掌握"拓展欧几里得算法"和"模线性方程求解"，二者是连接所有知识点的枢纽。