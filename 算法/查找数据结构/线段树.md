区间查询,任意问题,区间修改,单点修改
# 思想
使用线段区间管辖一个区间,父节点的线段是左右子节点的线段之和
这样可以做到区间修改与查询
# 实现
## 节点初始化:
```C
typedef struct node{
    int val;
    int laz;
    int size;
    int l;
    int r
}node tr[N*4];
```
laz为用于更新节点的懒标记
懒标记是需要更新在子节点上的,但是暂时未更新的值
数组一般开4倍大小
## 工具函数
得到左右孩子:
```C
int lc(int i){
    return 2*i+1;
}
int rc(int i){
    return 2*i+2;
}
```
进行向上更新:
```C
void pushup(int i){
    tr[i].val=tr[lc(i)].sum+tr[rc(i)].sum;
    tr[i].size=tr[lc(i)].size+tr[rc(i)].size+1;
}
```
进行向下更新(用父节点的懒标记更新子节点的懒标记与值):
```C
void pushdown(int i){
    if(!tr[i].laz) return ;
    tr[lc(i)].laz+=tr[i].laz;
    tr[rc(i)].laz+=tr[i].laz;
    tr[lc(i)].sum+=tr[i].laz*(tr[lc(i)].r-tr[lc(i)].l+1);
    tr[rc(i)].sum+=tr[i].laz*(tr[rc(i)].r-tr[rc(i)].l+1);
    tr[i].laz=0;
}
```
更新后要清空父节点的懒标记
初始化节点:
```C
void init(int i,int l,int r,int val){
    tr[i].l=l;
    tr[i].r=r;
    tr[i].val=val
    tr[i].size=1;
    tr[i].laz=0;
}
```
## 递归建树
```C
void build(int l,int r,int i){
    if(l==r) init(i,l,r,data[l]);
    else {
        int m=(l+r)>>1;
        build(l,m,lc(i));
        build(m+1,r,rc(i));
        init(i,l,r,0);
        pushup(i);
    }
}
```
记得更新父节点
## 询问操作
```C
int query(int l,int r,int i){ //查询节点i管辖的线段中,包含在[l,r]中的和

	if(tr[i].l>=l&&tr[i].r<=r) return tr[i].val;  //线段包含在所求区间内,直接返回

    pushdown(i);    //记得更新子节点

    int m=(tr[i].r+tr[i].l)>>1;

    int sum=0;
	if(l<=m) sum+=query(l,r,lc(i)); //说明所求区间有部分在线段的左半边
	
	if(r>=m+1) sum+=query(l,r,rc(i)); 

    return sum;
}
```
## 更改操作
```C
void change(int l,int r,int i,int delta){

	if(tr[i].l>=l&&tr[i].r<=r){  //线段包含在所求区间内,直接加上

        tr[i].val+=delta*(tr[i].r-tr[i].l+1);

		tr[i].laz+=delta;  //打上懒标记

    }else{

		pushdown(i);  //向下修改之前要处理一下历史遗留问题

        int m=(tr[i].l+tr[i].r)>>1;

        if(l<=m) change(l,r,lc(i),delta);  //说明所修改区间有部分在线段的左半边

        if(r>=m+1) change(l,r,rc(i),delta);

		pushup(i);  //向下修改完了要处理一下现在的节点的值

    }

}
```