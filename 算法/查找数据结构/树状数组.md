# 适用范围
区间查询,累计型问题(服从结合律,可差分),单点修改
有两个方法:单点加减常数,求区间的值(如求和)
# 思想
相当于线段树精简节点后得到的树,只保留了必要的区间,因此失去了区间修改的性质
但是,这样也使得整个树可以恰好塞到一个与原数组长度相同的数组中
具体管辖关系中,树状数组使用lowbit将区间结尾位置与区间长度关联起来
# 实现
## 前置:Lowbit
```C
void init_lowbit(){

    for (int i = 1; i <=SIZE; i++) lb[i]=(i&-i);  

}
```
一个数的lowbit是这个数最低位1所表示的10进制数
显见,相邻大小(不是位置)的$lb[i]$为二的倍数关系
**树状数组中,一个序号为i的节点管辖以i结尾,以$lb[i]$为长度的原数组的区间和**
## 更新方法
$v[i]$为树状数组中的节点,$t[i]$为原数组中的数据
更新$t[i]$时要将覆盖i的所有$v[i]$都更新
```C
void change(int d,int p){

    int i=p;

    while(i<=SIZE){

        v[i]+=d;

        i+=lb[i];

    }

}
```
$v[i]+=d$是说,已经更新了$v[i]$之后,要继续更新上级节点,由于$lb[i]$为二的倍数,上级节点的长度就是这一级节点的两倍,上级节点的左端点与这一级节点重合
那么,上级节点的右端点就是目前的位置加上当前节点的长度$lb[i]$
![](E:\a笔记\Markdown\算法\查找数据结构\图片\e411e5cf608a2119ec8753cf1c8f23c.png)

# 查找方法
先查找从头开始的和:
```C
int get_val(int end){

    if(end<=0) return 0;

    if(end==lb[end]) return v[end];

    return v[end]+get_val(end-lb[end]);

}
```
查找很好理解,先将目前右端点的节点管辖的区间和计入,再查找剩余长度的和即可
剩余长度就为当前结尾减去当前区间长度$lb[end]$
之后要查询片段和只要做差即可
```C
int ask(int l,int r){

    return get_val(r)-get_val(l-1);

}
```
类似于前缀和