### **Git 使用阐述大纲**

**第一部分：Git 的核心概念与底层架构**
*   **1.1 什么是版本控制**
    *   1.1.1 版本控制系统（VCS）的目标
    *   1.1.2 集中式版本控制与分布式版本控制的结构差异
*   **1.2 Git 的基础架构**
    *   1.2.1 Git 中的三种文件状态：已修改（Modified）、已暂存（Staged）、已提交（Committed）
    *   1.2.2 Git 项目的三个核心区域：工作目录（Working Directory）、暂存区（Staging Area / Index）、Git 仓库（.git Directory）
    *   1.2.3 Git 仓库（.git 目录）详解
        *   `objects` 目录：Blob、Tree 和 Commit 对象
        *   `HEAD` 文件：指向当前分支的指针
        *   `refs` 目录：指向提交对象的指针集合（分支与标签）
        *   `index` 文件：暂存区的物理体现
*   **1.3 Git 的数据存储方式**
    *   1.3.1 快照（Snapshot）而非差异（Delta）
    *   1.3.2 基于 SHA-1 哈希的对象命名与校验

**第二部分：Git 入门 - 初始化设置与基础指令**
*   **2.1 Git 的安装**
    *   2.1.1 针对不同操作系统（Windows, macOS, Linux）的安装说明
*   **2.2 首次运行的配置**
    *   2.2.1 设置用户名与邮箱 (`git config`)
    *   2.2.2 配置默认文本编辑器
*   **2.3 仓库的初始化**
    *   2.3.1 从零创建新仓库 (`git init`)
    *   2.3.2 克隆一个已存在的仓库 (`git clone`)
*   **2.4 Git 的基本工作流程详解**
    *   2.4.1 检查文件状态 (`git status`)
    *   2.4.2 跟踪新文件与暂存已修改文件 (`git add`)
    *   2.4.3 提交更新 (`git commit`)
    *   2.4.4 查看提交历史 (`git log`)

**第三部分：分支与合并 - 协同工作的核心**
*   **3.1 什么是分支**
    *   3.1.1 分支在 Git 中的本质：一个轻量级的、可移动的指针
    *   3.1.2 `master` / `main` 分支的定位
*   **3.2 分支管理**
    *   3.2.1 创建新分支 (`git branch <branch-name>`)
    *   3.2.2 切换分支 (`git checkout <branch-name>` 或 `git switch <branch-name>`)
    *   3.2.3 创建并立即切换到新分支
    *   3.2.4 列出所有分支 (`git branch`)
    *   3.2.5 删除分支 (`git branch -d <branch-name>`)
*   **3.3 合并操作**
    *   3.3.1 分支合并的概念
    *   3.3.2 快进式合并（Fast-forward）
    *   3.3.3 三方合并（Three-way merge）
    *   3.3.4 解决合并冲突（Merge Conflict）

**第四部分：远程仓库的使用**
*   **4.1 什么是远程仓库**
    *   4.1.1 远程仓库的目的（例如：GitHub, GitLab, Bitbucket）
*   **4.2 远程仓库管理**
    *   4.2.1 查看已配置的远程仓库 (`git remote -v`)
    *   4.2.2 添加新的远程仓库 (`git remote add <name> <url>`)
    *   4.2.3 移除远程仓库
*   **4.3 与远程仓库的交互**
    *   4.3.1 从远程仓库获取最新数据 (`git fetch`)
    *   4.3.2 拉取远程仓库的数据并合并 (`git pull`，阐述其与 `fetch` 的区别)
    *   4.3.3 推送本地提交到远程仓库 (`git push`)

**第五部分：Git 进阶概念与指令**
*   **5.1 撤销操作**
    *   5.1.1 修改最后一次提交 (`git commit --amend`)
    *   5.1.2 取消暂存的文件 (`git reset HEAD <file>`)
    *   5.1.3 撤销对工作目录中文件的修改 (`git checkout -- <file>` 或 `git restore <file>`)
    *   5.1.4 创建一个反向提交 (`git revert`)
    *   5.1.5 重置到历史中的某个提交 (`git reset`，阐述 `--soft`, `--mixed`, `--hard` 的区别)
*   **5.2 变基 (`git rebase`)**
    *   5.2.1 变基操作的概念
    *   5.2.2 使用交互式变基来整理提交历史
    *   5.2.3 变基的黄金法则：永远不要对公共分支进行变基
*   **5.3 储藏 (`git stash`)**
    *   5.3.1 临时保存未提交的修改
*   **5.4 标签 (`git tag`)**
    *   5.4.1 为重要提交（如版本发布）创建附注标签与轻量标签

现在，我将开始输出第一部分的内容。

---

### **第一部分：Git 的核心概念与底层架构**

#### **1.1 什么是版本控制**

##### **1.1.1 版本控制系统（VCS）的目标**
版本控制系统（Version Control System, VCS）是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。其核心目标包括：
*   **追踪历史：** 记录项目随时间演进的每一个变化。这使得开发者可以查看项目在任意时间点的状态。
*   **协同工作：** 允许多个开发者在同一个项目上并行工作，而不会互相干扰。系统提供了合并（Merge）不同开发者工作的机制。
*   **可恢复性：** 如果在开发过程中引入了错误，或者需要回退到之前的某个稳定版本，VCS 可以轻松地将项目恢复到指定的历史版本。
*   **分支开发：** 允许创建项目的独立开发线（称为“分支”），用于开发新功能或进行实验，而不会影响到项目的主线。开发完成后，这些分支可以被合并回主线。

##### **1.1.2 集中式版本控制与分布式版本控制的结构差异**
*   **集中式版本控制系统 (Centralized Version Control Systems, CVCS):**
    *   **结构：** 存在一个单一的中央服务器，该服务器保存着所有文件的所有版本。开发者从这个中央服务器检出（Checkout）文件到本地计算机进行工作。
    *   **工作流程：** 开发者在本地完成修改后，将变更提交（Commit）回中央服务器。其他开发者需要从服务器更新（Update）才能看到这些变更。
    *   **缺点：** 核心弱点在于单点故障。如果中央服务器宕机，所有开发者都无法协同工作。如果中央服务器的磁盘损坏且没有备份，项目的整个历史记录将会丢失。
    *   **代表系统：** Subversion (SVN), CVS。

*   **分布式版本控制系统 (Distributed Version Control Systems, DVCS):**
    *   **结构：** 每个开发者都拥有一个完整的项目仓库（Repository）的克隆（Clone），包括完整的历史记录。不存在单一的中央服务器，尽管通常会设立一个“中心”仓库以方便团队成员交换变更。
    *   **工作流程：** 开发者从一个远程仓库克隆项目到本地。所有的修改和提交都在本地仓库中完成，无需网络连接。当需要分享变更时，开发者将本地的提交推送（Push）到远程仓库。同样，他们可以从远程仓库拉取（Pull）其他人的变更到自己的本地仓库。
    *   **优点：**
        *   **鲁棒性：** 每个克隆都是一个完整的备份。即使“中心”服务器出现故障，任何一个开发者的本地仓库都可以用来恢复整个项目。
        *   **离线工作：** 大部分操作（如提交、查看历史、创建分支）都在本地进行，速度快且不依赖网络。
        *   **强大的分支与合并能力：** DVCS 的设计使得分支的创建和合并变得极其高效和廉价，极大地促进了基于分支的开发工作流。
    *   **代表系统：** Git, Mercurial。

#### **1.2 Git 的基础架构**

Git 的架构是理解其所有命令和工作流程的基础。

##### **1.2.1 Git 中的三种文件状态**
在一个 Git 项目中，任何一个文件都处于以下三种状态之一：
*   **已修改 (Modified):** 文件在工作目录中已被修改，但尚未保存到暂存区或提交到本地仓库。
*   **已暂存 (Staged):** 已修改的文件被标记，表示其当前版本将包含在下一次提交的快照中。这个标记动作通常通过 `git add` 命令完成。
*   **已提交 (Committed):** 文件的数据已经安全地保存在本地的 Git 仓库中。

##### **1.2.2 Git 项目的三个核心区域**
这三种状态与 Git 项目的三个核心工作区域直接对应：
*   **工作目录 (Working Directory):** 这是开发者实际进行工作的区域。它是从 Git 仓库的数据库中检出（Checkout）的某个版本，并放置在本地文件系统中，供开发者使用或修改。
*   **暂存区 (Staging Area / Index):** 这是一个文件，通常位于 Git 仓库目录中。它保存了关于下一次将要提交的文件信息的列表。当你执行 `git add` 命令时，实际上是将文件从工作目录添加到暂存区，准备进行提交。
*   **Git 仓库 (.git Directory):** 这是 Git 用来保存项目的元数据和对象数据库的地方。这是 Git 中最重要的部分。当你从别处克隆一个仓库时，复制的就是这个目录；当你 `git commit` 时，提交的内容就保存在这个目录里。

**工作流程总结：**
1.  在 **工作目录** 中修改文件。
2.  将想要包含在下一次提交中的文件变更，通过 `git add` 命令放入 **暂存区**。
3.  执行 `git commit` 命令，将 **暂存区** 中的文件快照永久性地记录到 **Git 仓库** 中。

##### **1.2.3 Git 仓库（.git 目录）详解**
`.git` 目录是 Git 仓库的核心。它包含了 Git 维护项目历史所需的所有对象和引用。
*   **`objects` 目录:** 这是 Git 的对象数据库。Git 中所有的数据都存储为“对象”。主要有三种对象类型：
    *   **Blob (Binary Large Object):** 用于存储文件的内容。每个文件的每个版本都对应一个 blob 对象。Git 不关心文件内容是什么，只将其视为一团二进制数据。
    *   **Tree:** 用于表示目录结构。一个 tree 对象包含了一系列指向其他 tree 对象（代表子目录）或 blob 对象（代表文件）的指针，以及它们对应的文件名、模式等信息。它代表了项目在某个时间点的快照。
    *   **Commit:** 这是 Git 中最核心的对象。一个 commit 对象指向一个顶层的 tree 对象（代表该次提交时项目的根目录快照），并包含了作者、提交者、提交日期和提交信息等元数据。此外，它还包含一个或多个指向父提交（Parent Commit）的指针，从而构成了项目的提交历史链。第一个提交没有父提交，一次常规的合并提交会有两个父提交。

*   **`HEAD` 文件:** 这是一个特殊的指针文件。它通常指向当前所在的本地分支。例如，如果 `HEAD` 文件的内容是 `ref: refs/heads/main`，这表示你当前在 `main` 分支上工作。当你切换分支时，`HEAD` 文件的内容会随之改变。

*   **`refs` 目录:** 这个目录存储了指向 commit 对象的引用（指针）。
    *   `refs/heads/`：存放本地分支。每个文件名对应一个分支名，文件内容是该分支指向的最新 commit 对象的 SHA-1 哈希值。
    *   `refs/tags/`：存放标签。每个标签文件指向一个特定的 commit 对象，用于标记重要的里程碑（如版本发布）。

*   **`index` 文件:** 这是暂存区的物理实现。它是一个二进制文件，当你执行 `git add` 时，Git 会将文件的信息（SHA-1 哈希、文件名等）写入这个文件。当你执行 `git commit` 时，Git 会使用这个 `index` 文件来创建新的 tree 对象，并最终生成 commit 对象。

#### **1.3 Git 的数据存储方式**

##### **1.3.1 快照（Snapshot）而非差异（Delta）**
这是 Git 与许多其他版本控制系统（如 SVN）的根本区别。
*   其他系统大多存储文件随时间变化的差异信息（Deltas）。它们记录每个文件从一个版本到下一个版本的具体变更内容。
*   Git 则不同，它在每次提交时，都会对当时的整个项目制作一个快照并保存。如果文件没有变化，Git 不会再次存储该文件，而是只保留一个指向之前已存储文件的链接。这种方式使得 Git 在获取项目历史版本、进行分支和合并等操作时速度极快，因为它不需要通过层层叠加差异来计算出某个版本的完整内容，而是直接读取该版本的快照。

##### **1.3.2 基于 SHA-1 哈希的对象命名与校验**
Git 数据库中的所有内容，包括 blob、tree 和 commit 对象，都不是通过文件名来索引的，而是通过其内容的 SHA-1 哈希值。
*   **SHA-1 哈希：** 这是一个由 40 个十六进制字符组成的字符串（例如 `24b9da6552252987aa493b52f8696cd6d3b00373`）。它是根据对象的内容（对于 commit 和 tree，还包括其元数据）计算出来的唯一标识符。
*   **完整性校验：** 由于哈希值是根据内容计算的，这意味着如果对象的内容发生任何改变，其 SHA-1 哈希值也必然会改变。这保证了 Git 仓库中数据的完整性。你从 Git 仓库中取出的任何文件或对象，其哈希值都会被重新计算并与原始哈希值进行比对，确保数据在传输或存储过程中没有损坏。
*   **对象引用：** Git 内部通过这些哈希值来引用对象。例如，一个 commit 对象通过哈希值指向一个 tree 对象，一个 tree 对象通过哈希值指向多个 blob 和其他 tree 对象。这种结构形成了一个有向无环图（DAG），构成了 Git 仓库的底层数据结构。

---
好的，我们继续。

---

### **第二部分：Git 入门 - 初始化设置与基础指令**

本部分将阐述如何安装和配置 Git，以及如何创建和克隆仓库，并详细介绍日常版本控制工作中最核心的四个基本指令。

#### **2.1 Git 的安装**

在开始使用 Git 之前，需要在您的计算机上安装它。

##### **2.1.1 针对不同操作系统（Windows, macOS, Linux）的安装说明**
*   **Windows:**
    1.  访问 Git 的官方网站：[https://git-scm.com/](https://git-scm.com/)
    2.  下载适用于 Windows 的最新安装程序。
    3.  运行安装程序。在安装过程中，建议接受大部分默认设置，它们对于初学者是友好且实用的。安装包中会包含 **Git Bash**，这是一个模拟 Linux Bash 环境的命令行工具，推荐使用它来执行 Git 命令。

*   **macOS:**
    *   **通过 Homebrew (推荐):** 如果您安装了 Homebrew 包管理器，只需在终端中运行以下命令：
        ```bash
        brew install git
        ```
    *   **通过 Xcode 命令行工具:** 如果您安装了 Xcode，Git 很可能已经随其命令行工具一同安装。您可以在终端中运行 `git --version` 来检查。如果未安装，系统通常会提示您安装命令行工具。

*   **Linux:**
    *   **基于 Debian/Ubuntu 的发行版:** 打开终端并运行：
        ```bash
        sudo apt-get update
        sudo apt-get install git
        ```
    *   **基于 Fedora/CentOS/RHEL 的发行版:** 打开终端并运行：
        ```bash
        # 对于 Fedora 或较新的 RHEL/CentOS
        sudo dnf install git
        # 对于较旧的 RHEL/CentOS
        sudo yum install git
        ```

安装完成后，您可以在终端或 Git Bash 中运行 `git --version` 来验证 Git 是否已成功安装，并查看其版本号。

#### **2.2 首次运行的配置**

安装 Git 后，第一件应该做的事情是进行全局配置，主要是设置您的用户身份。这个身份信息会嵌入到您创建的每一次提交中，并且是不可更改的。

##### **2.2.1 设置用户名与邮箱 (`git config`)**
在终端中执行以下两条命令，将 `"Your Name"` 和 `"youremail@example.com"` 替换为您自己的信息：
```bash
git config --global user.name "Your Name"
git config --global user.email "youremail@example.com"
```
*   `--global` 标志表示这个配置适用于当前操作系统用户下的所有 Git 仓库。如果您希望对某个特定的项目使用不同的身份，可以在该项目的目录下运行不带 `--global` 标志的相同命令。

##### **2.2.2 配置默认文本编辑器**
当 Git 需要您输入一些信息时（例如提交信息），它会调用一个默认的文本编辑器。您可以根据自己的偏好进行配置。例如，将默认编辑器设置为 Vim：
```bash
git config --global core.editor "vim"
```
您可以将其替换为您喜欢的任何编辑器，如 `nano`, `emacs`, 或 `code` (Visual Studio Code)。

要检查您的配置信息，可以运行 `git config --list`。

#### **2.3 仓库的初始化**

有两种获取 Git 项目仓库的方式。

##### **2.3.1 从零创建新仓库 (`git init`)**
如果您有一个尚未进行版本控制的项目目录，可以进入该目录并执行 `git init` 来创建一个新的 Git 仓库。
1.  创建一个新目录：`mkdir my_project`
2.  进入该目录：`cd my_project`
3.  初始化仓库：`git init`

该命令会创建一个名为 `.git` 的子目录。这个目录包含了仓库所需的骨架文件，此时，您的项目就已经处于 Git 的监控之下了，但还没有任何文件被跟踪。

##### **2.3.2 克隆一个已存在的仓库 (`git clone`)**
如果您想获取一个已经存在的远程 Git 仓库的副本（例如，托管在 GitHub 上的项目），您需要使用 `git clone` 命令。
```bash
git clone https://github.com/git/git.git
```
这条命令会执行以下操作：
1.  在当前目录下创建一个名为 `git` 的新目录。
2.  将远程仓库的所有数据，包括每一个文件的每一个版本的完整历史，都下载到这个目录下的 `.git` 文件夹中。
3.  自动检出（Checkout）项目的最新版本到工作目录，使其处于可用状态。
4.  自动设置一个指向源仓库的远程连接，默认名称为 `origin`。

#### **2.4 Git 的基本工作流程详解**

日常的 Git 工作遵循一个基本模式：修改文件，暂存变更，然后提交。

##### **2.4.1 检查文件状态 (`git status`)**
这是您最常使用的 Git 命令。它用于查看工作目录和暂存区的当前状态。
*   **在一个新初始化的仓库中运行 `git status`**，它会告诉您当前在哪个分支，以及没有需要提交的内容。
*   **创建一个新文件后运行 `git status`**，它会列出这个文件，并标记为“未跟踪的文件 (Untracked files)”。这意味着 Git 已经注意到了这个文件的存在，但它还没有被纳入版本控制。

##### **2.4.2 跟踪新文件与暂存已修改文件 (`git add`)**
`git add` 命令是一个多功能命令，其核心作用是将工作目录中的变更移动到暂存区，为下一次提交做准备。
*   **跟踪新文件:** 对于一个未跟踪的文件（例如 `README.md`），运行 `git add README.md`。再次运行 `git status`，您会看到该文件现在处于“变更将被提交 (Changes to be committed)”的状态，这表明它已经被放入暂存区。
*   **暂存已修改文件:** 如果您修改了一个已经被 Git 跟踪的文件，`git status` 会将其列为“尚未暂存以备提交的变更 (Changes not staged for commit)”。运行 `git add <文件名>` 会将这个文件的当前版本快照放入暂存区。
*   **暂存所有变更:** 使用 `git add .` 可以将当前目录下所有已修改和未跟踪的文件（不包括被 `.gitignore` 忽略的文件）一次性添加到暂存区。

##### **2.4.3 提交更新 (`git commit`)**
当您已经使用 `git add` 将所有希望包含的变更都放入暂存区后，就可以使用 `git commit` 命令来将这些变更永久地记录到本地仓库的历史中。
*   执行 `git commit` 命令时，会启动您配置的文本编辑器，要求您输入本次提交的说明信息。
*   一个更快捷的方式是使用 `-m` 标志直接在命令行中提供提交信息：
    ```bash
    git commit -m "Initial commit: Add README.md"
    ```
    **提交的本质：** 一次提交会创建一个新的 commit 对象，该对象包含了指向暂存区内容快照（一个 tree 对象）的指针、作者信息、时间戳、提交说明，以及指向上一个提交（父提交）的指针。

##### **2.4.4 查看提交历史 (`git log`)**
提交完成后，您可以使用 `git log` 命令来查看项目的提交历史。
*   默认情况下，`git log` 会按时间倒序列出所有提交，显示每个提交的 SHA-1 校验和、作者、日期和提交信息。
*   `git log` 有许多有用的选项来格式化其输出：
    *   `--oneline`: 将每个提交压缩到一行显示，只包含 SHA-1 值的前几个字符和提交信息。
    *   `--graph`: 在输出的左侧绘制一个 ASCII 文本图形，表示分支和合并的历史。
    *   `--all`: 显示所有分支的历史，而不仅仅是当前分支。
    *   一个常用的组合是 `git log --oneline --graph`，它可以清晰地展示项目的演进历史。

---
好的，我们继续进行第三部分。

---

### **第三部分：分支与合并 - 协同工作的核心**

分支是 Git 的一项核心特性，它允许开发者在不影响项目主线（通常是 `main` 或 `master` 分支）的情况下，独立地进行新功能开发、Bug 修复或实验性工作。

#### **3.1 什么是分支**

##### **3.1.1 分支在 Git 中的本质：一个轻量级的、可移动的指针**
从底层架构来看，Git 中的分支并不是项目代码的一份完整拷贝。它仅仅是一个指向某个特定提交（Commit）对象的轻量级指针。
*   **实现机制：** 一个分支实际上是一个存储在 `.git/refs/heads/` 目录下的简单文件。文件名就是分支名，文件内容是该分支所指向的 commit 对象的 40 位 SHA-1 哈希值。
*   **轻量级：** 创建一个新分支，本质上只是创建一个新文件并写入一个 SHA-1 值，这个操作几乎是瞬时完成的，占用的存储空间极小。这与一些传统的版本控制系统形成鲜明对比，在那些系统中，创建分支通常意味着要复制整个项目的代码，既耗时又占用大量空间。
*   **可移动性：** 当你在一个分支上创建一个新的提交时，这个分支的指针会自动向前移动，指向这个最新的提交。

##### **3.1.2 `master` / `main` 分支的定位**
`master`（在较新的 Git 仓库中通常命名为 `main`）分支在技术上与其他任何分支没有区别。它不是一个特殊的分支。它的特殊性完全是基于约定的：
*   它是在初始化一个新的 Git 仓库时 (`git init`) 默认创建的第一个分支的名称。
*   在团队协作中，它通常被用作项目的主干，代表了项目的稳定、可发布的状态。

#### **3.2 分支管理**

Git 提供了一系列命令来高效地管理分支。

##### **3.2.1 创建新分支 (`git branch <branch-name>`)**
这个命令会创建一个新的分支，但它 **不会** 自动将你切换到这个新分支上。
```bash
git branch feature-login
```
执行该命令后，会创建一个名为 `feature-login` 的新指针，它指向你当前所在的提交。你仍然停留在当前分支。

##### **3.2.2 切换分支 (`git checkout <branch-name>` 或 `git switch <branch-name>`)**
要开始在一个分支上工作，你需要先切换到它。
*   **使用 `git checkout`:**
    ```bash
    git checkout feature-login
    ```
    这个命令会执行两个核心操作：
    1.  更新 `HEAD` 指针，使其指向 `feature-login` 分支。
    2.  将工作目录中的文件内容更新为 `feature-login` 分支所指向的那个提交快照的状态。

*   **使用 `git switch` (推荐):**
    较新版本的 Git 引入了 `git switch` 命令，其功能更专一，专门用于分支切换，可以避免 `git checkout` 命令的多重用途（它既能切换分支，也能恢复文件）所带来的混淆。
    ```bash
    git switch feature-login
    ```

##### **3.2.3 创建并立即切换到新分支**
这是一个非常常见的操作，Git 为此提供了快捷方式。
*   **使用 `git checkout`:**
    ```bash
    git checkout -b feature-payment
    ```
    这等同于 `git branch feature-payment` 和 `git checkout feature-payment` 两条命令的组合。

*   **使用 `git switch`:**
    ```bash
    git switch -c feature-payment
    ```
    `-c` 标志代表 "create"。

##### **3.2.4 列出所有分支 (`git branch`)**
不带任何参数的 `git branch` 命令会列出你本地仓库中的所有分支。
```bash
git branch
```
输出结果中，当前所在的分支（即 `HEAD` 指针所指向的分支）前面会有一个星号 `*` 标记。

##### **3.2.5 删除分支 (`git branch -d <branch-name>`)**
当一个功能分支的工作完成并被合并回主线后，通常就可以删除它了。
```bash
git branch -d feature-login
```
*   `-d` (或 `--delete`) 是一个安全选项。如果 `feature-login` 分支上的工作还没有被合并到当前分支，Git 会阻止删除并给出提示。
*   如果你确定要丢弃某个未合并分支上的工作，并强制删除它，可以使用 `-D` (大写) 标志。

#### **3.3 合并操作**

合并（Merge）是将一个分支的修改集成到另一个分支的过程。

##### **3.3.1 分支合并的概念**
假设你完成了 `feature-login` 分支的开发，现在需要将这些新功能合并回 `main` 分支。
1.  首先，切换到接收变更的分支，即 `main` 分支：
    ```bash
    git switch main
    ```
2.  然后，执行 `git merge` 命令，指定你想要合并进来的分支：
    ```bash
    git merge feature-login
    ```

##### **3.3.2 快进式合并（Fast-forward）**
这是一种最简单的合并场景。它发生在：你要合并的目标分支 (`main`) 的当前提交，是待合并分支 (`feature-login`) 历史的直接祖先。换句话说，在你开发 `feature-login` 分支期间，`main` 分支没有任何新的提交。

在这种情况下，Git 不会创建新的合并提交。它只是简单地将 `main` 分支的指针向前移动，使其指向与 `feature-login` 分支相同的提交。这个过程因为只是移动指针，所以被称为“快进”。

##### **3.3.3 三方合并（Three-way merge）**
这是更常见的合并场景。它发生在：从一个共同的祖先提交开始，`main` 分支和 `feature-login` 分支各自都有了新的提交，开发历史产生了分叉。

在这种情况下，Git 无法简单地移动指针。它会执行一次“三方合并”，具体步骤如下：
1.  Git 会找出两个分支（`main` 和 `feature-login`）的最新提交，以及它们共同的祖先提交。
2.  Git 会将这三个提交的快照进行比较和合并。
3.  Git 会自动创建一个新的提交，称为“合并提交 (Merge Commit)”。这个合并提交很特殊，因为它有两个父提交（一个来自 `main`，一个来自 `feature-login`）。
4.  `main` 分支的指针会移动到这个新创建的合并提交上。

##### **3.3.4 解决合并冲突（Merge Conflict）**
在进行三方合并时，如果两个分叉的分支修改了同一个文件的同一部分，Git 将无法自动决定应该保留哪个版本。这时，Git 会暂停合并过程，并报告一个“合并冲突”。
你需要手动解决这个冲突：
1.  运行 `git status`，它会列出处于冲突状态的文件。
2.  打开这些冲突文件。Git 会在文件中插入特殊的冲突标记，如下所示：
    ```
    <<<<<<< HEAD
    这是 main 分支中的内容。
    =======
    这是 feature-login 分支中的内容。
    >>>>>>> feature-login
    ```
    *   `<<<<<<< HEAD` 到 `=======` 之间的部分是当前分支（`main`）的内容。
    *   `=======` 到 `>>>>>>> feature-login` 之间的部分是待合并分支 (`feature-login`) 的内容。
3.  你的任务是编辑这个文件，删除这些冲突标记，并决定最终应该保留的内容（可以是其中一个版本，也可以是两者的结合，或者是全新的内容）。
4.  在解决了所有文件中的所有冲突后，使用 `git add` 命令来标记这些文件为已解决状态：
    ```bash
    git add <文件名>
    ```5.  当所有冲突都已解决并暂存后，执行 `git commit` 来创建合并提交，完成整个合并过程。此时你不需要提供提交信息，Git 会生成一个默认的合并信息。

---
好的，我们继续进行第三部分。

---

### **第三部分：分支与合并 - 协同工作的核心**

分支是 Git 的一项核心特性，它允许开发者在不影响项目主线（通常是 `main` 或 `master` 分支）的情况下，独立地进行新功能开发、Bug 修复或实验性工作。

#### **3.1 什么是分支**

##### **3.1.1 分支在 Git 中的本质：一个轻量级的、可移动的指针**
从底层架构来看，Git 中的分支并不是项目代码的一份完整拷贝。它仅仅是一个指向某个特定提交（Commit）对象的轻量级指针。
*   **实现机制：** 一个分支实际上是一个存储在 `.git/refs/heads/` 目录下的简单文件。文件名就是分支名，文件内容是该分支所指向的 commit 对象的 40 位 SHA-1 哈希值。
*   **轻量级：** 创建一个新分支，本质上只是创建一个新文件并写入一个 SHA-1 值，这个操作几乎是瞬时完成的，占用的存储空间极小。这与一些传统的版本控制系统形成鲜明对比，在那些系统中，创建分支通常意味着要复制整个项目的代码，既耗时又占用大量空间。
*   **可移动性：** 当你在一个分支上创建一个新的提交时，这个分支的指针会自动向前移动，指向这个最新的提交。

##### **3.1.2 `master` / `main` 分支的定位**
`master`（在较新的 Git 仓库中通常命名为 `main`）分支在技术上与其他任何分支没有区别。它不是一个特殊的分支。它的特殊性完全是基于约定的：
*   它是在初始化一个新的 Git 仓库时 (`git init`) 默认创建的第一个分支的名称。
*   在团队协作中，它通常被用作项目的主干，代表了项目的稳定、可发布的状态。

#### **3.2 分支管理**

Git 提供了一系列命令来高效地管理分支。

##### **3.2.1 创建新分支 (`git branch <branch-name>`)**
这个命令会创建一个新的分支，但它 **不会** 自动将你切换到这个新分支上。
```bash
git branch feature-login
```
执行该命令后，会创建一个名为 `feature-login` 的新指针，它指向你当前所在的提交。你仍然停留在当前分支。

##### **3.2.2 切换分支 (`git checkout <branch-name>` 或 `git switch <branch-name>`)**
要开始在一个分支上工作，你需要先切换到它。
*   **使用 `git checkout`:**
    ```bash
    git checkout feature-login
    ```
    这个命令会执行两个核心操作：
    1.  更新 `HEAD` 指针，使其指向 `feature-login` 分支。
    2.  将工作目录中的文件内容更新为 `feature-login` 分支所指向的那个提交快照的状态。

*   **使用 `git switch` (推荐):**
    较新版本的 Git 引入了 `git switch` 命令，其功能更专一，专门用于分支切换，可以避免 `git checkout` 命令的多重用途（它既能切换分支，也能恢复文件）所带来的混淆。
    ```bash
    git switch feature-login
    ```

##### **3.2.3 创建并立即切换到新分支**
这是一个非常常见的操作，Git 为此提供了快捷方式。
*   **使用 `git checkout`:**
    ```bash
    git checkout -b feature-payment
    ```
    这等同于 `git branch feature-payment` 和 `git checkout feature-payment` 两条命令的组合。

*   **使用 `git switch`:**
    ```bash
    git switch -c feature-payment
    ```
    `-c` 标志代表 "create"。

##### **3.2.4 列出所有分支 (`git branch`)**
不带任何参数的 `git branch` 命令会列出你本地仓库中的所有分支。
```bash
git branch
```
输出结果中，当前所在的分支（即 `HEAD` 指针所指向的分支）前面会有一个星号 `*` 标记。

##### **3.2.5 删除分支 (`git branch -d <branch-name>`)**
当一个功能分支的工作完成并被合并回主线后，通常就可以删除它了。
```bash
git branch -d feature-login
```
*   `-d` (或 `--delete`) 是一个安全选项。如果 `feature-login` 分支上的工作还没有被合并到当前分支，Git 会阻止删除并给出提示。
*   如果你确定要丢弃某个未合并分支上的工作，并强制删除它，可以使用 `-D` (大写) 标志。

#### **3.3 合并操作**

合并（Merge）是将一个分支的修改集成到另一个分支的过程。

##### **3.3.1 分支合并的概念**
假设你完成了 `feature-login` 分支的开发，现在需要将这些新功能合并回 `main` 分支。
1.  首先，切换到接收变更的分支，即 `main` 分支：
    ```bash
    git switch main
    ```
2.  然后，执行 `git merge` 命令，指定你想要合并进来的分支：
    ```bash
    git merge feature-login
    ```

##### **3.3.2 快进式合并（Fast-forward）**
这是一种最简单的合并场景。它发生在：你要合并的目标分支 (`main`) 的当前提交，是待合并分支 (`feature-login`) 历史的直接祖先。换句话说，在你开发 `feature-login` 分支期间，`main` 分支没有任何新的提交。

在这种情况下，Git 不会创建新的合并提交。它只是简单地将 `main` 分支的指针向前移动，使其指向与 `feature-login` 分支相同的提交。这个过程因为只是移动指针，所以被称为“快进”。

##### **3.3.3 三方合并（Three-way merge）**
这是更常见的合并场景。它发生在：从一个共同的祖先提交开始，`main` 分支和 `feature-login` 分支各自都有了新的提交，开发历史产生了分叉。

在这种情况下，Git 无法简单地移动指针。它会执行一次“三方合并”，具体步骤如下：
1.  Git 会找出两个分支（`main` 和 `feature-login`）的最新提交，以及它们共同的祖先提交。
2.  Git 会将这三个提交的快照进行比较和合并。
3.  Git 会自动创建一个新的提交，称为“合并提交 (Merge Commit)”。这个合并提交很特殊，因为它有两个父提交（一个来自 `main`，一个来自 `feature-login`）。
4.  `main` 分支的指针会移动到这个新创建的合并提交上。

##### **3.3.4 解决合并冲突（Merge Conflict）**
在进行三方合并时，如果两个分叉的分支修改了同一个文件的同一部分，Git 将无法自动决定应该保留哪个版本。这时，Git 会暂停合并过程，并报告一个“合并冲突”。
你需要手动解决这个冲突：
1.  运行 `git status`，它会列出处于冲突状态的文件。
2.  打开这些冲突文件。Git 会在文件中插入特殊的冲突标记，如下所示：
    ```
    <<<<<<< HEAD
    这是 main 分支中的内容。
    =======
    这是 feature-login 分支中的内容。
    >>>>>>> feature-login
    ```
    *   `<<<<<<< HEAD` 到 `=======` 之间的部分是当前分支（`main`）的内容。
    *   `=======` 到 `>>>>>>> feature-login` 之间的部分是待合并分支 (`feature-login`) 的内容。
3.  你的任务是编辑这个文件，删除这些冲突标记，并决定最终应该保留的内容（可以是其中一个版本，也可以是两者的结合，或者是全新的内容）。
4.  在解决了所有文件中的所有冲突后，使用 `git add` 命令来标记这些文件为已解决状态：
    ```bash
    git add <文件名>
    ```5.  当所有冲突都已解决并暂存后，执行 `git commit` 来创建合并提交，完成整个合并过程。此时你不需要提供提交信息，Git 会生成一个默认的合并信息。



---

### **第四部分：远程仓库的使用**

到目前为止，我们所有的操作都发生在本地仓库（`.git` 目录）中。为了与团队成员协作，或者将项目代码备份到服务器上，我们需要使用远程仓库。

#### **4.1 什么是远程仓库**

远程仓库（Remote Repository）是指托管在网络上或另一台计算机上的项目版本库。开发者可以从这个仓库克隆项目，将自己的本地提交推送上去，以及拉取他人的提交。

##### **4.1.1 远程仓库的目的**
*   **协同工作：** 远程仓库是团队成员之间共享代码的中心点。它提供了一个所有人都认可的“真实来源 (Source of Truth)”。
*   **数据备份：** 将本地仓库的完整历史推送到远程仓库，相当于为项目创建了一个异地备份。即使本地计算机发生故障，项目的历史记录也不会丢失。
*   **多点访问：** 允许开发者从不同的计算机（例如，办公室的台式机和家里的笔记本电脑）访问和贡献同一个项目。
*   **常见的托管服务：** GitHub, GitLab, Bitbucket 是目前最流行的 Git 远程仓库托管服务，它们在提供代码存储的基础上，还增加了问题跟踪、代码审查（Pull/Merge Request）、持续集成等协作功能。

#### **4.2 远程仓库管理**

Git 使用 `git remote` 命令来管理一系列你所追踪的远程仓库。

##### **4.2.1 查看已配置的远程仓库 (`git remote -v`)**
要查看当前项目配置了哪些远程仓库，可以运行 `git remote` 命令。
```bash
git remote
```
这会列出每个远程仓库的简称（shortname）。例如，在你克隆一个仓库后，至少会看到一个名为 `origin` 的远程仓库。

为了看到每个简称对应的 URL，可以使用 `-v` (verbose) 选项：
```bash
git remote -v
```
输出会显示每个远程仓库的抓取（fetch）和推送（push）地址。
```
origin  https://github.com/user/repo.git (fetch)
origin  https://github.com/user/repo.git (push)
```

##### **4.2.2 添加新的远程仓库 (`git remote add <name> <url>`)**
你可以为项目添加新的远程仓库。这在需要与多个远程仓库协作时非常有用（例如，一个是自己的，另一个是开源项目的原始仓库）。
```bash
git remote add upstream https://github.com/original-owner/repo.git
```
这条命令添加了一个名为 `upstream` 的新远程仓库，其地址为指定的 URL。现在你就可以使用 `upstream` 这个简称来指代这个仓库了。

##### **4.2.3 移除远程仓库**
如果需要移除一个远程仓库的配置，可以使用 `git remote remove` 或 `git remote rm`。
```bash
git remote remove upstream
```
这个命令只会移除本地仓库中对该远程仓库的引用配置，并不会以任何方式影响远程仓库本身。

#### **4.3 与远程仓库的交互**

与远程仓库的日常交互主要涉及三个命令：`fetch`, `pull`, 和 `push`。

##### **4.3.1 从远程仓库获取最新数据 (`git fetch`)**
`git fetch` 命令会连接到指定的远程仓库，并下载所有本地仓库中还没有的数据。
```bash
git fetch origin
```
这个命令会执行以下操作：
1.  它会抓取 `origin` 仓库中所有分支的更新。
2.  它会更新本地仓库中的“远程跟踪分支”（Remote-tracking branches），例如 `origin/main`。这些分支是只读的指针，反映了远程仓库在上次连接时的状态。
3.  **关键点：** `git fetch` **不会** 自动修改你的本地工作分支（例如 `main`），也不会更新你的工作目录。它只是获取数据，让你可以在本地查看和决定如何处理这些更新。这是一个安全的操作，因为它不会影响你当前的工作。

##### **4.3.2 拉取远程仓库的数据并合并 (`git pull`，阐述其与 `fetch` 的区别)**
`git pull` 命令在大多数情况下可以看作是 `git fetch` 和 `git merge` 两个命令的组合。
```bash
git pull origin main
```
这条命令会：
1.  从 `origin` 远程仓库的 `main` 分支 **获取** (fetch) 最新的提交。
2.  将获取到的远程 `origin/main` 分支 **合并** (merge) 到你当前所在的本地分支中。

**`fetch` 与 `pull` 的核心区别：**
*   **`git fetch`** 是一个保守的操作。它只下载新数据，让你有机会在合并前检查变更（例如，使用 `git log origin/main` 查看远程分支的提交历史）。这给了你更多的控制权。
*   **`git pull`** 是一个更自动化的操作。它下载新数据并立即尝试将其合并到你当前的工作中。这很方便，但也可能在没有预先审查的情况下直接引入合并冲突。

**工作流建议：** 对于更复杂的项目或需要仔细审查变更的场景，推荐使用 `git fetch` + 手动 `git merge` 或 `git rebase` 的工作流。对于简单的个人项目或明确知道远程没有冲突的场景，`git pull` 是一个快捷的选择。

##### **4.3.3 推送本地提交到远程仓库 (`git push`)**
当你想要分享你的本地提交时，你需要使用 `git push` 命令将它们上传到远程仓库。
```bash
git push <remote-name> <branch-name>
```
例如，要将本地 `main` 分支的提交推送到 `origin` 远程仓库：
```bash
git push origin main
```
**推送的先决条件：**
Git 只允许你进行“快进式推送”（Fast-forward push）。这意味着，在你上次从远程仓库拉取数据之后，如果其他团队成员已经向该远程分支推送了新的提交，你的推送将会被拒绝。

在这种情况下，Git 会提示你远程仓库包含了你本地没有的工作。你必须先使用 `git pull` (或 `fetch` 和 `merge`) 将远程的变更拉取到本地，解决可能出现的合并冲突，然后再重新尝试推送。这个机制确保了你不会无意中覆盖他人的工作。



---

### **第五部分：Git 进阶概念与指令**

本部分将介绍一些更高级的 Git 操作，它们能帮助你更灵活地管理提交历史、处理未完成的工作以及标记重要的项目节点。

#### **5.1 撤销操作**

在版本控制中，撤销或修改之前的操作是常见需求。Git 提供了多种工具来应对不同场景下的撤销需求。

##### **5.1.1 修改最后一次提交 (`git commit --amend`)**
这个命令用于修改你刚刚完成的最后一次提交。它并不会真的去“修改”那个旧的提交，而是会用一个新的提交来 **替换** 它。
*   **使用场景1：修改提交信息。** 如果你提交后发现提交信息有拼写错误或不够清晰，可以运行：
    ```bash
    git commit --amend
    ```
    这会打开你的文本编辑器，里面包含了上一次的提交信息，修改并保存后，新的提交就会替换掉旧的。
*   **使用场景2：添加忘记的文件。** 如果你提交后发现漏掉了一个文件，可以先将该文件添加到暂存区，然后运行 `--amend`：
    ```bash
    git add forgotten_file.txt
    git commit --amend --no-edit
    ```    `--no-edit` 标志表示不修改提交信息，直接将暂存区的新内容合并到上一次的提交中，并生成一个新的替换提交。
*   **警告：** 如果你已经将这个提交推送到了远程仓库，应避免使用 `git commit --amend`，因为它会改写历史，可能给其他协作者带来问题。

##### **5.1.2 取消暂存的文件 (`git reset HEAD <file>`)**
如果你使用 `git add` 将一个文件添加到了暂存区，但后来决定不将它的本次修改包含在下一次提交中，你可以将其“取消暂存”。
```bash
git reset HEAD <file>
```
这个命令不会改变工作目录中的文件内容，它只是将暂存区中的该文件恢复到 `HEAD`（最后一次提交）的状态。文件的修改仍然保留在你的工作目录中。
*   **现代语法：** 新版本的 Git 提供了 `git restore` 命令，其意图更清晰：
    ```bash
    git restore --staged <file>
    ```

##### **5.1.3 撤销对工作目录中文件的修改 (`git checkout -- <file>` 或 `git restore <file>`)**
如果你在工作目录中修改了一个文件，但决定放弃这些修改，想把它恢复到最近一次提交时的状态。
*   **传统语法：**
    ```bash
    git checkout -- <file>
    ```
    `--` 是一个重要的分隔符，用于告诉 Git 后面的参数是文件名而不是分支名。
*   **现代语法 (推荐):**
    ```bash
    git restore <file>
    ```
*   **警告：** 这是一个破坏性操作。任何你在工作目录中对该文件所做的、但尚未提交的修改都会被永久丢弃，无法恢复。

##### **5.1.4 创建一个反向提交 (`git revert`)**
`git revert` 用于撤销一个已经存在的提交，但它是通过创建一个 **新的提交** 来实现的。这个新的提交会引入与目标提交完全相反的变更。
```bash
git revert <commit-hash>
```
*   **使用场景：** 这是在 **公共分支**（例如 `main`）上撤销提交的安全方式。因为它不改写项目历史，而是向前追加历史，所以对于已经推送到远程并被团队成员拉取的提交，使用 `revert` 是唯一的正确选择。它清晰地记录了“我们曾经做了A，现在我们决定撤销A”这一过程。

##### **5.1.5 重置到历史中的某个提交 (`git reset`)**
`git reset` 是一个强大的命令，它用于将当前分支的 `HEAD` 指针移动到历史中的某个指定提交。它有三种主要模式，对工作目录和暂存区的影响各不相同。

假设当前分支历史为 `A-B-C (HEAD)`，我们想重置到提交 `A` (`git reset A`)：
*   **`--soft`:**
    ```bash
    git reset --soft A
    ```
    1.  **Git 仓库:** 将 `HEAD` 和当前分支指针移动到 `A`。
    2.  **暂存区:** **不** 改变。暂存区仍然包含了提交 `B` 和 `C` 所做的所有变更。
    3.  **工作目录:** **不** 改变。
    *   **结果：** 你的提交历史回到了 `A`，但所有从 `A` 到 `C` 的变更都作为“已暂存”的变更保留了下来，你可以立即 `git commit` 来将这些变更合并成一个全新的提交。

*   **`--mixed` (默认模式):**
    ```bash
    git reset --mixed A  # 或者 git reset A
    ```
    1.  **Git 仓库:** 将 `HEAD` 和当前分支指针移动到 `A`。
    2.  **暂存区:** **会** 被重置，使其内容与提交 `A` 的快照保持一致。
    3.  **工作目录:** **不** 改变。
    *   **结果：** 提交历史回到了 `A`，所有从 `A` 到 `C` 的变更都保留在工作目录中，但状态变为了“未暂存的修改”。

*   **`--hard`:**
    ```bash
    git reset --hard A
    ```
    1.  **Git 仓库:** 将 `HEAD` 和当前分支指针移动到 `A`。
    2.  **暂存区:** **会** 被重置，使其内容与提交 `A` 的快照保持一致。
    3.  **工作目录:** **会** 被重置，使其内容与提交 `A` 的快照保持一致。
    *   **结果：** 这是一个彻底的重置。所有从 `A` 到 `C` 的变更，无论是在暂存区还是工作目录，都将被 **永久丢弃**。这是一个破坏性操作，请谨慎使用。

#### **5.2 变基 (`git rebase`)**

变基是集成不同分支变更的另一种方式，与合并（merge）相对。它的核心思想是：将一个分支上的提交序列，在另一个分支的末端“重新播放”一遍。

##### **5.2.1 变基操作的概念**
假设你有如下分叉历史：
```
      A---B---C   (feature)
     /
D---E---F---G   (main)
```
如果你在 `feature` 分支上执行 `git rebase main`，Git 会：
1.  找到两个分支的共同祖先 `E`。
2.  获取 `feature` 分支相对于 `E` 的所有提交（即 `A`, `B`, `C`）的补丁。
3.  将 `feature` 分支的指针重置到 `main` 分支的最新提交 `G` 上。
4.  依次将之前保存的补丁（`A`, `B`, `C`）应用到 `G` 之后，创建出内容相同但哈希值全新的提交 `A'`, `B'`, `C'`。

结果历史会变成一条直线：
```
D---E---F---G---A'---B'---C'   (feature)
           |
          (main)
```
*   **优点：** 变基可以产生一个非常整洁、线性的提交历史，没有不必要的合并提交。
*   **与合并的区别：** 合并保留了历史的真实分叉路径，通过一个合并提交将它们连接起来。变基则是通过重写历史来创造一个线性的历史。

##### **5.2.2 使用交互式变基来整理提交历史**
`git rebase -i` (interactive) 是一个极其强大的工具，它允许你在“重新播放”提交的过程中，对这些提交进行修改、合并、拆分或重新排序。
```bash
git rebase -i HEAD~3  # 整理最近的3个提交
```
执行后，Git 会打开一个文本编辑器，列出这3个提交，每个提交前都有一个 `pick` 命令。你可以将 `pick` 修改为：
*   `reword`: 保留提交内容，但修改提交信息。
*   `edit`: 保留提交内容，但暂停变基过程，让你对该提交进行更复杂的修改（例如拆分提交）。
*   `squash`: 将这个提交与前一个提交合并，并让你编辑一个新的提交信息。
*   `fixup`: 类似 `squash`，但直接丢弃这个提交的信息，使用前一个提交的信息。
*   `drop`: 完全丢弃这个提交。

##### **5.2.3 变基的黄金法则：永远不要对公共分支进行变基**
**绝对不要对一个已经推送到远程、并且团队中其他人可能已经基于其进行开发的分支执行变基操作。**
因为变基会创建全新的提交来替换旧的提交，它是在重写历史。如果你重写了公共历史，当其他协作者拉取更新时，他们的本地历史会与你重写后的历史产生严重分叉，导致极其混乱和难以解决的合并问题。变基只应用于清理你尚未分享的本地提交。

#### **5.3 储藏 (`git stash`)**

当你正在一个分支上处理一项复杂的工作，但此时需要紧急切换到另一个分支修复一个 Bug，而你当前的工作尚未完成，不适合创建一个完整的提交。这时 `git stash` 就派上用场了。

##### **5.3.1 临时保存未提交的修改**
*   `git stash`: 该命令会将你工作目录和暂存区中的所有未提交的修改（包括已跟踪和已暂存的）保存到一个临时的“储藏栈”中，然后将你的工作目录恢复到 `HEAD` 提交时的干净状态。
*   `git stash list`: 查看储藏栈中保存的所有工作。
*   `git stash apply`: 将最近一次储藏的内容恢复到你的工作目录，但 **不** 从储藏栈中移除它。
*   `git stash pop`: 将最近一次储藏的内容恢复到你的工作目录，并从储藏栈中 **移除** 它。这是最常用的恢复命令。

#### **5.4 标签 (`git tag`)**

标签用于为项目历史中的某个特定时间点（通常是一个提交）创建一个永久性的、有意义的标记。

##### **5.4.1 为重要提交（如版本发布）创建附注标签与轻量标签**
Git 支持两种类型的标签：
*   **轻量标签 (Lightweight Tag):**
    它就像一个不会移动的分支，仅仅是一个指向特定提交的指针。
    ```bash
    git tag v1.0.0
    ```
*   **附注标签 (Annotated Tag):**
    这是 Git 官方推荐使用的类型。它是一个存储在 Git 数据库中的完整对象，包含了标签创建者的名字、邮箱、创建日期、一条标签信息，并且可以被 GPG 签名和验证。
    ```bash
    git tag -a v1.0.0 -m "Release version 1.0.0"
    ```
*   **推送标签：** 默认情况下，`git push` 不会传送标签。你必须显式地推送标签：
    ```bash
    git push origin v1.0.0      # 推送单个标签
    git push origin --tags      # 推送所有本地尚未在远程的标签
    ```

