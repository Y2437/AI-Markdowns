## 💎 Java 修饰符 **极限** 深度解析 (The **Definitive** Guide)

Java 修饰符分为两大阵营：**访问控制**修饰符（控制可见性）和**非访问**修饰符（控制特性/行为）。

### 第一部分：深度访问控制修饰符 (Access Modifiers)

这类修饰符控制了类、接口、变量、方法或构造方法在 Java 程序的生命周期中的可见范围。

| 修饰符 | 类/接口作用 (顶层) | 变量作用 (字段) | 方法/构造器作用 |
| :--- | :--- | :--- | :--- |
| **`private`** | **× 禁止**修饰外部类。✔ 仅允许修饰**内部类/嵌套类**，使其只能在外部类内部使用。 | **封装最高级别。** 仅在变量所属的**类内部**可见，外部通过 getter/setter 间接操作。 | 仅在方法所属的**类内部**可被调用。 **注意：** 不能与 `abstract` 同时使用。 |
| **`(default)`** | **包级私有。** 只能在**同一包**内被引用。常用于仅提供给同包代码使用的工具类。 | **包级可见性。** 只能被同一包内的类访问和修改。 | 只能被同一包内的类调用。 |
| **`protected`** | **× 禁止**修饰外部类或接口。✔ 仅允许修饰**内部类/嵌套类**。 | **跨包受控可见。** 1. 同一包内所有类可见。 2. 不同包的子类可以访问从父类继承来的该成员。 **(见下文深度解析)** | **跨包受控可见。** 允许同一包内所有类调用，且允许不同包的子类重写和调用继承来的方法。 **注意：** 不能修饰构造方法重载，只能修饰原始构造方法。 |
| **`public`** | **项目全局可见。** 如果是类，该文件**必须**以该类命名。接口成员默认为 `public abstract` (方法) 或 `public static final` (变量)。 | **全局开放。** 在整个项目中所有位置都可被访问和修改。 | **全局开放。** 在整个项目中所有位置都可被调用。 |

---

### **特别聚焦：`protected` 修饰符的深层限制与规则**

`protected` 在跨包（`Package`）继承时有复杂的**“自引用规则”**。

1.  **基础可见性：** 同一包内的任何类（包括非子类）都可以访问父类 `P` 的 `protected` 成员 `m`。
2.  **跨包子类限制：** 若子类 `S` 与父类 `P` **不在同一包**，则 `S` 对 `P` 的 `protected` 成员 `m` 的访问受到严格限制。

| 访问情景 | 可见性 (在子类 S 中) | 约束或特殊规则 |
| :--- | :--- | :--- |
| **访问自身继承而来的 `m`** | ✔ 允许 (例如 `this.m` 或直接使用 `m`) | 访问是通过**继承**发生的，完全合法。 |
| **通过子类 `S` 的实例引用访问 `m`** | ✔ 允许 (例如 `S s = new S(); s.m`) | Java 编译器认为这仍然是子类对其继承属性的“代入式”访问。 |
| **通过父类 `P` 的实例引用访问 `m`** | **❌ 拒绝** (例如 `P p = new P(); p.m`) | 因为父类实例 `p` 与子类 `S` **不在同一包**，且 `p` **不是** `S` 的类型，Java 阻止了这种非继承方式的访问。 |
| **通过兄弟子类 `S2` 的实例引用访问 `m`** | **❌ 拒绝** (例如 `S2 s2 = new S2(); s2.m`) | `S2` 虽然也继承了 `m`，但在 `S` 中访问 `s2.m` 仍然不符合“受保护访问只能通过自身继承或自身引用发生”的原则。**不能通过其他子类的引用来访问共同基类的 `protected` 成员。** |
| **对于 `static protected` 成员** | **✔ 允许** | 静态成员没有实例依赖，**不遵循上述严格的实例引用限制**。子类无论是否同包，均可通过类名或直接引用访问继承来的静态成员。 |

---

### 第二部分：深度非访问修饰符 (Non-Access Modifiers)

这类修饰符用于控制类、方法或变量的行为、存储位置、多线程特性等。

#### 1. `static`（静态修饰符）

| 作用对象 | 特性与限制 | 深度解析 |
| :--- | :--- | :--- |
| **变量 (成员变量)**| **类变量，独一无二。** 所有该类的实例共享同一个 `static` 变量，内存中只存储一份。 | **内存分配时机：** 在类加载时被初始化。 **初始化顺序：** 先于实例初始化（构造器或代码块）。 |
| **方法** | **类方法，直接访问。** 可直接通过类名调用，无需创建实例。 | **核心限制：** `static` 方法中**禁止**使用 `this` 和 `super` 关键字。 **内部访问限制：** `static` 方法**禁止**直接调用非静态（实例）方法或访问非静态（实例）成员变量，因为实例尚未创建。 |
| **代码块** | **静态代码块。** 在类加载时执行，且**只执行一次**，通常用于初始化复杂的静态资源。 | **执行优先级：** 高于所有构造方法和实例代码块。 |
| **类 (内部类)**| **静态嵌套类。** 它本质上被视为顶级类，不需要外部类的实例即可创建。 | **访问限制：** 它**不能**访问外部类的非静态（实例）成员变量或方法，只能访问外部类的 `static` 成员。 |

#### 2. `final`（最终修饰符）

| 作用对象 | 特性与限制 | 深度解析 |
| :--- | :--- | :--- |
| **类** | **不可继承。** 标志该类的设计已完成，不允许被任何其他类作为父类继承。 | 提升安全性与明确设计意图（例如 `java.lang.String`）。 |
| **方法** | **不可重写 (Override)。** 子类不能改变此方法的实现逻辑。 | 常用于保护父类的核心业务逻辑，避免被恶意或错误重写。 **注意：** `private` 方法天生不可重写（子类看不到），因此同时使用 `private final` 是多余的。 |
| **变量 (成员 & 局部)** | **值不可变（常量）。** 变量只能被赋值一次，一旦赋值就不能再改变其值或引用。 | **基本类型：** 变量值本身固定。 **引用类型：** **引用**本身固定（不可指向新对象），但引用的**对象内部状态**（如果对象本身可变）是允许改变的。 **成员变量初始化：** 必须在声明时或构造器（或静态块）中完成初始化。 |

#### 3. `abstract`（抽象修饰符）

| 作用对象 | 特性与限制 | 深度解析 |
| :--- | :--- | :--- |
| **类** | **抽象类。** 1. 不能直接被 `new` 关键字实例化（必须通过子类实现）。 2. 可以包含抽象方法和非抽象方法。 | **继承义务：** 任何继承了抽象类的**非抽象**子类，**必须**重写实现其所有的抽象方法。 |
| **方法** | **抽象方法（无体方法）。** 只有声明（方法签名），没有实现体 `{}`，以分号 `;` 结束。 | **环境约束：** 只能存在于抽象类或接口中。 **禁止组合：** **禁止**与 `private`, `final`, `static`, `synchronized`, `native`, `strictfp` 共同使用，因为这些修饰符会阻止方法被子类实现或违背抽象本质。 |
| **变量** | **× 禁止**修饰变量。 | - |

#### 4. `synchronized`（同步修饰符）

| 作用对象 | 特性与限制 | 深度解析 |
| :--- | :--- | :--- |
| **方法 (实例方法)** | **对象锁。** 当一个线程进入 `synchronized` 实例方法时，它会获取当前方法所属的**实例对象（即 `this`）的锁**。 | **互斥访问：** 同一时间只允许一个线程访问该对象**所有** `synchronized` 实例方法，但可以同时访问非同步方法。 |
| **方法 (静态方法)** | **类锁。** 当一个线程进入 `synchronized static` 方法时，它会获取当前方法所属的**类的 Class 对象**的锁。 | **全局互斥：** 类锁是唯一的，能阻止任何线程进入该类的**所有**同步静态方法。实例方法的对象锁和静态方法的类锁互不影响。 |
| **代码块** | **细粒度同步。** 通过括号中的对象（锁对象）进行锁定，实现更小的临界区。 | 提升效率，比同步整个方法性能更好，但需要自己指定一个**监视器对象**（Monitor）。 |
| **类/变量** | **× 禁止**修饰类或变量。 | - |

#### 5. `volatile`（易失修饰符）

| 作用对象 | 特性与限制 | 深度解析 |
| :--- | :--- | :--- |
| **变量 (成员变量)** | **内存可见性与顺序性。** | **可见性保障：** 确保当一个线程修改变量值时，其他线程能够立即看到新值，强制从主内存而不是线程的本地工作内存中读取/写入。 **顺序性保障：** 具有“禁止指令重排”的语义，保证变量的操作顺序与代码顺序一致。 **非原子性缺陷：** 仅保证了可见性和顺序性，但**不能保证操作的原子性**（例如 `i++` 仍然是非原子操作，可能出现竞态条件）。 |
| **方法/类/局部变量** | **× 禁止**修饰这些结构。 | - |

#### 6. 其他特殊修饰符

| 修饰符 | 作用对象 | 特性与限制 | 深度解析 |
| :--- | :--- | :--- | :--- |
| **`transient`** | **变量 (成员变量)** | **瞬态。** 序列化时跳过该变量。 | 当对象被序列化（持久化或网络传输）时，标记为 `transient` 的变量**不会被写入**流中。反序列化时，这些变量会被赋予其数据类型的**默认值**（引用类型为 `null`，基本数值类型为 `0` 等）。 |
| **`native`** | **方法** | **本地方法。** 标记该方法的具体实现是用 JNI (Java Native Interface) 通过 C/C++ 等底层语言编写的。 | 该方法在 Java 中只有声明（无实现体），通常用于与操作系统底层或非 Java 库进行交互。 |
| **`strictfp`**| **类、接口、方法**| **严格浮点。** 确保浮点数计算结果在所有 JVM 平台上**完全一致**（遵守 IEEE 754 标准）。 | 目的在于**移植性和一致性**，牺牲部分 JIT 优化的灵活性。在方法上使用时，仅该方法内部计算严格。在类或接口上使用时，其内部所有方法（除非被显式移除 `strictfp`）都严格。 |