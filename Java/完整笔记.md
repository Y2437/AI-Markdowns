好的，我将根据您提供的演示文稿材料，为您撰写一份详细、专业且准确的Java面向对象编程笔记。

首先，这是整份笔记的详细大纲：

### **Java面向对象编程高级笔记 - 大纲**

---

#### **第一部分：面向对象编程（OOP）基础**

*   **第1章：编程范式与Java入门**
    *   1.1 编程语言的发展阶段：从面向过程到面向对象
    *   1.2 核心思想对比：面向过程设计 vs. 面向对象设计
    *   1.3 面向对象的基本思想与四大特性（抽象、封装、继承、多态）
    *   1.4 Java语言简介：历史、特性与应用领域
    *   1.5 Java的运行机制：编译与解释（JVM、字节码、JIT）
    *   1.6 第一个Java程序：HelloWorld详解

*   **第2章：类与对象：构建软件的基本单元**
    *   2.1 类与对象的概念与关系
    *   2.2 类的设计与定义：语法结构与设计原则
    *   2.3 成员变量（属性/字段）：定义对象的状态
    *   2.4 成员方法（行为）：定义对象的操作
    *   2.5 构造方法（Constructor）：对象的初始化
    *   2.6 对象的创建与内存分析：`new`关键字、栈与堆
    *   2.7 对象的生命周期与垃圾回收（GC）机制

#### **第二部分：面向对象三大核心特性详解**

*   **第3章：封装：信息隐藏与访问控制**
    *   3.1 封装的定义与必要性
    *   3.2 访问控制修饰符：`private`, `protected`, `public` 及默认（包访问权限）
    *   3.3 `this`关键字详解
    *   3.4 实现封装：Getter与Setter方法

*   **第4章：继承：代码复用与层次结构**
    *   4.1 继承的必要性与“is-a”关系
    *   4.2 继承的实现：`extends`关键字
    *   4.3 `super`关键字：调用父类成员
    *   4.4 方法覆盖（Override）与变量隐藏
    *   4.5 子类构造过程与`super()`的调用
    *   4.6 `final`关键字在继承中的应用
    *   4.7 继承的利弊与组合/聚合关系

*   **第5章：多态：统一接口与多样实现**
    *   5.1 多态的必要性与核心思想
    *   5.2 多态的实现条件：继承、方法覆盖、向上转型
    *   5.3 向上转型（Upcasting）与向下转型（Downcasting）
    *   5.4 `instanceof`操作符
    *   5.5 抽象类与抽象方法 (`abstract`)
    *   5.6 接口 (`interface`)：定义行为契约
    *   5.7 抽象类与接口的对比

#### **第三部分：高级类特性与设计模式**

*   **第6章：高级类特性**
    *   6.1 `static`关键字：类变量与类方法
    *   6.2 静态代码块与实例代码块
    *   6.3 内部类：成员内部类、静态内部类、局部内部类、匿名内部类
    *   6.4 `Object`类：所有类的根
    *   6.5 `equals()`方法与`==`操作符的区别

*   **第7章：面向对象设计原则与设计模式**
    *   7.1 核心设计原则：高内聚低耦合、SOLID原则
    *   7.2 设计模式概述：创建型、结构型、行为型
    *   7.3 创建型模式：单例模式、工厂模式（简单工厂、工厂方法、抽象工厂）
    *   7.4 结构型模式：适配器模式、装饰器模式
    *   7.5 行为型模式：策略模式、观察者模式、责任链模式

#### **第四部分：Java核心API与高级应用**

*   **第8章：异常处理**
    *   8.1 错误与异常的分类
    *   8.2 Java异常体系结构：`Throwable`, `Error`, `Exception`
    *   8.3 异常处理机制：`try-catch-finally`
    *   8.4 声明与抛出异常：`throws`与`throw`
    *   8.5 自定义异常

*   **第9章：Java集合框架**
    *   9.1 集合框架概述与核心接口
    *   9.2 泛型（Generics）的应用
    *   9.3 `Collection`接口：`List`与`Set`
    *   9.4 `Map`接口
    *   9.5 迭代器（`Iterator`）
    *   9.6 `Collections`工具类
    *   9.7 函数式编程与Lambda表达式入门

*   **第10章：多线程程序设计**
    *   10.1 进程与线程的概念
    *   10.2 线程的生命周期与状态
    *   10.3 线程的创建与启动：继承`Thread`类与实现`Runnable`接口
    *   10.4 线程同步：`synchronized`关键字
    *   10.5 线程通信：`wait()`, `notify()`, `notifyAll()`
    *   10.6 线程死锁

*   **第11章：文件与I/O流**
    *   11.1 `File`类：文件与目录管理
    *   11.2 I/O流的概念：字节流与字符流
    *   11.3 字节流：`InputStream`与`OutputStream`
    *   11.4 字符流：`Reader`与`Writer`
    *   11.5 过滤流（装饰器模式的应用）：缓冲流、数据流、对象流
    *   11.6 对象序列化（`Serializable`）

*   **第12章：网络编程**
    *   12.1 网络编程基础：TCP/IP协议、Socket
    *   12.2 TCP编程：`ServerSocket`与`Socket`
    *   12.3 UDP编程：`DatagramSocket`与`DatagramPacket`

*   **第13章：图形用户界面（GUI）编程**
    *   13.1 AWT与Swing简介
    *   13.2 容器与组件
    *   13.3 布局管理器
    *   13.4 事件处理模型

好的，我们开始。以下是笔记的第一部分，第1章的详细内容。

---

### **Java面向对象编程高级笔记**

---

#### **第一部分：面向对象编程（OOP）基础**

---

#### **第1章：编程范式与Java入门**

本章旨在建立对面向对象编程（Object-Oriented Programming, OOP）宏观思想的理解，并将其与传统的面向过程编程进行对比。同时，本章将介绍Java语言的历史、特性及其在软件开发中的核心地位，并通过经典的HelloWorld程序，解析Java程序的基本结构与运行机制。

##### **1.1 编程语言的发展阶段**

编程语言作为人与计算机沟通的桥梁，其发展大致经历了以下几个阶段：

1.  **面向机器语言 (Machine Language)**
    *   **定义**：直接由二进制代码（0和1）组成的指令集，是计算机CPU能够直接识别和执行的唯一语言。
    *   **特性**：
        *   **底层性**：直接操作硬件，效率极高。
        *   **非移植性**：与特定硬件（CPU架构）紧密绑定，为一种硬件编写的机器码无法在另一种硬件上运行。
        *   **可读性差**：对人类程序员极其不友好，编写和调试极为困难。例如，计算 `1+1` 的机器码可能是一串复杂的二进制序列，如 `10111000 01000001 ...`。

2.  **汇编语言 (Assembly Language)**
    *   **定义**：使用助记符（Mnemonics）来代替机器指令的二进制码，如用 `MOV` 代表数据移动，`ADD` 代表加法。
    *   **特性**：
        *   **改进的可读性**：相比机器语言，汇编语言更易于阅读和编写。
        *   **底层性**：仍然是面向机器的低级语言，程序员需要处理具体的寄存器、内存地址等硬件细节。
        *   **非移植性**：同样与特定硬件架构相关。

3.  **面向过程语言 (Procedural Language)**
    *   **定义**：以过程（或函数）为中心来组织代码，将程序看作是一系列待执行的指令序列。C语言是其典型代表。
    *   **特性**：
        *   **高级语言**：语法更接近自然语言，将程序员从繁琐的硬件细节中解放出来。
        *   **结构化编程**：通过函数调用来组织代码，实现了代码的模块化。
        *   **关注点**：核心在于“做什么”，即解决问题的步骤和算法。

4.  **面向对象语言 (Object-Oriented Language)**
    *   **定义**：将现实世界中的事物抽象为程序中的“对象”，程序由一系列对象的协作来完成。Java、C++是其典型代表。
    *   **特性**：
        *   **思维模式**：更符合人类认识世界的方式，将数据和操作数据的行为封装在一起。
        *   **核心优势**：提供了更好的代码可维护性、可扩展性和可复用性。
        *   **关注点**：核心在于“谁来做”，即由哪个对象来执行哪个动作。

##### **1.2 核心思想对比：面向过程设计 vs. 面向对象设计**

1.  **面向过程设计 (Procedure-Oriented Programming, POP)**
    *   **核心思想**：**自顶向下的功能分解**。将一个复杂的任务分解为一系列更小的、易于管理的函数（或过程）。
    *   **程序结构**：`算法 + 数据结构`。数据和处理数据的算法是分离的。
    *   **思维范式**：“动宾”结构，关注执行的“动作”。
    *   **示例**：“把大象放进冰箱”
        1.  `打开冰箱()`
        2.  `放入大象()`
        3.  `关闭冰箱()`
    *   **缺点**：当系统规模变大、需求变更频繁时，数据和算法的分离会导致代码耦合度高，维护困难。

2.  **面向对象设计 (Object-Oriented Programming, OOP)**
    *   **核心思想**：**识别并建模问题域中的实体（对象）**。程序由对象的交互构成。
    *   **程序结构**：`对象 + 消息`。数据（属性）和操作数据的方法（行为）被封装在对象内部。
    *   **思维范式**：“主谓”结构，关注执行动作的“主体”（对象）。
    *   **开发步骤**：
        1.  **分析 (Analysis)**：识别问题域中的所有实体，并将其抽象为类。例如，在“饲养动物”场景中，识别出“饲养员”、“动物”、“食物”等。
        2.  **设计 (Design)**：为每个类定义其应有的属性（状态）和方法（行为）。
        3.  **实现 (Implementation)**：分析类与类之间的关系（如继承、依赖），并用代码实现。
    *   **示例**：“把大象放进冰箱”
        1.  识别对象：`大象 (Elephant)`、`冰箱 (Fridge)`。
        2.  定义对象行为：`冰箱`有`open()`、`store(Food food)`、`close()`方法；`大象`是一个`Food`。
        3.  交互：通过调用`冰箱`对象的方法来完成任务。

##### **1.3 面向对象的基本思想与四大特性**

*   **基本思想**：将现实世界中的事物（实体）映射为软件系统中的对象，并通过模拟这些对象之间的交互来构建系统。其核心在于尽可能运用人类的自然思维方式，如分类、抽象等。**万物皆对象**。

*   **四大核心特性**：
    1.  **抽象 (Abstraction)**：提取事物的共同特征（属性和行为），忽略非本质的细节，形成类的过程。
    2.  **封装 (Encapsulation)**：将数据（属性）和操作数据的方法（行为）捆绑为一个独立的实体（对象），并对对象的内部细节进行隐藏，只暴露有限的公共接口。
    3.  **继承 (Inheritance)**：允许一个类（子类）获取另一个类（父类）的属性和方法，实现了代码复用和“is-a”关系。
    4.  **多态 (Polymorphism)**：指同一个行为或接口，作用于不同的对象时，可以有不同的实现方式和表现形态。

##### **1.4 Java语言简介**

*   **创始人**：James Gosling。
*   **命名**：源于一种咖啡的名字（爪哇咖啡），寓意为世界带来一杯“热咖啡”。
*   **发展历史**：
    *   1995年，Sun Microsystems公司正式发布Java。
    *   1996年，发布第一个正式版本JDK 1.0。
    *   1999年，发布三大版本：**标准版 (Java SE)**、**企业版 (Java EE)** 和 **微型版 (Java ME)**。
    *   2009年，Oracle（甲骨文）公司收购Sun，获得Java版权。
    *   Java版本持续迭代，不断引入新特性。

*   **应用领域**：
    *   Web开发（后端服务）
    *   智能终端应用（Android开发）
    *   云计算与大数据（Hadoop生态）
    *   人工智能与虚拟现实

##### **1.5 Java的运行机制：编译与解释**

Java采用的是一种**先编译后解释**的混合执行模型，这是其实现“一次编写，到处运行”（Write Once, Run Anywhere, WORA）的关键。

1.  **编译阶段**：
    *   程序员编写的源代码文件以 `.java` 为扩展名。
    *   使用Java编译器（`javac.exe`）对 `.java` 文件进行编译。
    *   编译的结果不是特定平台的机器码，而是生成一种平台无关的**字节码（Bytecode）**，存储在 `.class` 文件中。

2.  **运行阶段**：
    *   **Java虚拟机 (Java Virtual Machine, JVM)** 是一个抽象的计算机，它在具体的操作系统（如Windows, Linux, macOS）之上提供一个统一的运行环境。
    *   使用Java解释器（`java.exe`）启动JVM。
    *   JVM加载 `.class` 文件，并逐行解释执行其中的字节码。
    *   **即时编译器 (Just-In-Time, JIT)**：为了提高性能，JVM内部包含一个JIT编译器。它会在运行时将频繁执行的“热点”字节码编译成本地机器码，从而实现接近编译型语言的执行效率。

这个机制结合了编译型语言的高效性和解释型语言的跨平台性。

##### **1.6 第一个Java程序：HelloWorld详解**

```java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("hello world!");
    }
}
```

**代码结构解析**：

*   `public class HelloWorld { ... }`
    *   `class`：关键字，用于声明一个类。
    *   `HelloWorld`：类名。根据Java规范，如果一个类被 `public` 修饰，那么包含它的源文件名必须与类名完全相同（即 `HelloWorld.java`）。
    *   `public`：访问修饰符，表示这个类是公共的，可以被任何其他类访问。

*   `public static void main(String[] args) { ... }`
    *   这是Java程序的**入口方法**。JVM在运行时会寻找并执行这个方法。
    *   `public`：访问修饰符，表示该方法可以被JVM从外部调用。
    *   `static`：关键字，表示该方法是静态的（类方法），JVM无需创建类的实例即可直接调用。
    *   `void`：返回值类型，表示该方法不返回任何值。
    *   `main`：方法名，这是JVM规定的固定名称。
    *   `String[] args`：方法参数，用于接收程序启动时传入的命令行参数。

*   `System.out.println("hello world!");`
    *   这是一个执行输出操作的语句。
    *   `System`：`java.lang`包中的一个final类。
    *   `out`：`System`类中的一个`public static final`成员变量，它是一个`PrintStream`类型的对象，代表标准输出流（通常是控制台）。
    *   `println()`：`PrintStream`类的一个方法，用于打印字符串并换行。

---

好的，我们继续。以下是笔记的第二部分，第3章的详细内容。

---

### **Java面向对象编程高级笔记**

---

#### **第二部分：面向对象三大核心特性详解**

---

#### **第3章：封装：信息隐藏与访问控制**

封装是面向对象编程的三大核心特性之一，其本质在于信息隐藏和访问控制。本章将详细阐述封装的定义、必要性，并深入讲解如何通过访问控制修饰符、`this`关键字以及Getter/Setter方法来实现有效的封装。

##### **3.1 封装的定义与必要性**

1.  **定义 (Encapsulation)**
    *   **双重含义**：
        1.  **数据与行为的捆绑**：将对象的属性（数据）和操作这些属性的方法（行为）结合成一个不可分割的独立单元——即类。
        2.  **信息隐藏 (Information Hiding)**：隐藏对象内部的实现细节，只对外暴露必要的、受控的公共接口。外部世界无法直接访问对象的内部状态，只能通过这些公共接口与之交互。

2.  **必要性**
    *   **提高安全性**：防止外部代码随意修改对象内部的状态，避免非法或不合理的数据赋值。例如，一个 `Dog` 类的 `age` 属性，如果不封装，外部代码可以直接赋值为负数（`d.age = -5;`），这在逻辑上是错误的。
    *   **降低耦合度**：封装使得类的内部实现可以自由修改，只要对外暴露的公共接口保持不变，就不会影响到使用该类的其他代码。这增强了系统的模块化和独立性。
    *   **提高易用性**：通过提供简洁、清晰的公共接口，隐藏了复杂的内部逻辑。使用者只需关心“做什么”（调用接口），而无需关心“怎么做”（内部实现）。例如，全自动洗衣机提供“标准模式”按钮，用户无需关心内部洗涤、漂洗、脱水的复杂流程。
    *   **增强代码可维护性**：当需求变更时，修改通常被限制在类的内部，降低了维护成本和引入新错误的风险。

##### **3.2 访问控制修饰符**

Java提供了四个访问控制修饰符，用于控制类、接口、变量和方法的可见性。

| Modifier           | Class | Package | Subclass (不同包) | World |
| :----------------- | :---: | :-----: | :---------------: | :---: |
| `public`           |   Y   |    Y    |         Y         |   Y   |
| `protected`        |   Y   |    Y    |         Y         |   N   |
| no modifier (默认) |   Y   |    Y    |         N         |   N   |
| `private`          |   Y   |    N    |         N         |   N   |

*   **`public` (公共)**
    *   **可见性**：最高级别，可以在任何地方被访问。
    *   **应用**：通常用于定义类的公共接口（API），如公共方法和常量。

*   **`protected` (受保护)**
    *   **可见性**：对**同一个包**内的所有类可见，并且对**不同包中的子类**可见。
    *   **应用**：主要用于继承体系中，允许子类访问和修改父类的某些内部状态或行为。

*   **默认 (包访问权限)**
    *   **可见性**：当不使用任何访问修饰符时，成员只能被**同一个包**内的其他类访问。
    *   **应用**：用于实现包级别的封装，当某些辅助类或方法只希望在包内部使用时。

*   **`private` (私有)**
    *   **可见性**：最低级别，只能在**定义它的类内部**被访问。
    *   **应用**：是实现封装的核心。类的成员变量通常应声明为 `private`，以防止外部直接访问。

##### **3.3 `this`关键字详解**

`this` 是一个关键字，它在方法或构造方法内部代表**当前对象**的引用。

1.  **区分成员变量和局部变量**
    *   当方法的参数名或局部变量名与成员变量名相同时，必须使用 `this` 来明确指定访问的是成员变量。

    ```java
    public class Cat {
        private String name;
    
        public void setName(String name) {
            // this.name 指的是成员变量
            // name 指的是方法参数
            this.name = name; 
        }
    }
    ```

2.  **在构造方法中调用其他构造方法**
    *   一个构造方法可以使用 `this(...)` 来调用同一个类中的另一个重载构造方法。
    *   **规则**：`this(...)` 调用必须是构造方法中的**第一条语句**。

    ```java
    public class Animal {
        private String name;
    
        public Animal() {
            System.out.println("Constructor 1 is running!");
        }
    
        public Animal(String name) {
            this(); // 调用无参构造方法
            this.name = name;
            System.out.println("Constructor 2 is running!");
        }
    }
    ```

3.  **返回当前对象的引用**
    *   方法可以返回 `this`，以支持链式调用。

    ```java
    public class Calculator {
        private int result;
    
        public Calculator add(int num) {
            this.result += num;
            return this; // 返回当前对象
        }
    }
    // 链式调用: calc.add(5).add(10);
    ```

##### **3.4 实现封装：Getter与Setter方法**

为了在隐藏内部数据的同时提供受控的访问，通常为私有成员变量提供一对公共的Getter和Setter方法。

*   **Setter方法 (修改器)**
    *   **作用**：用于设置私有成员变量的值。
    *   **命名规范**：`public void set<PropertyName>(<Type> value)`，例如 `setName(String name)`。
    *   **核心价值**：可以在方法内部加入数据验证逻辑，确保赋给成员变量的值是合法的。

*   **Getter方法 (访问器)**
    *   **作用**：用于获取私有成员变量的值。
    *   **命名规范**：`public <Type> get<PropertyName>()`，例如 `getName()`。对于布尔类型的变量，通常使用 `is<PropertyName>()`，例如 `isMale()`。

**封装示例**：

```java
public class Employee {
    // 1. 将属性私有化
    private String name;
    private String gender;

    // 2. 提供公共的Setter方法，并加入验证逻辑
    public void setGender(String gender) {
        if ("男".equals(gender) || "女".equals(gender)) {
            this.gender = gender;
        } else {
            System.out.println("性别输入错误，请重新设置！");
        }
    }

    // 3. 提供公共的Getter方法
    public String getGender() {
        return this.gender;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return this.name;
    }
}
```

**使用封装后的代码**：

```java
public class EmployeeDemo {
    public static void main(String[] args) {
        Employee jack = new Employee();
        
        // 编译错误：gender 属性是 private 的，无法直接访问
        // jack.gender = "不是男人"; 

        // 必须通过公共的Setter方法设置
        jack.setGender("男"); 
        jack.setGender("不是男人"); // 会触发验证逻辑，赋值失败
    }
}
```

通过这种方式，`Employee` 类完全控制了其 `gender` 属性的修改，保证了数据的有效性和安全性，从而实现了封装

好的，我们继续。以下是笔记的第二部分，第4章的详细内容。

---

### **Java面向对象编程高级笔记**

---

#### **第二部分：面向对象三大核心特性详解** (续)

---

#### **第4章：继承：代码复用与层次结构**

继承是面向对象编程的三大核心特性之一，它允许一个类（子类）获取另一个类（父类）的属性和方法。本章将深入探讨继承的机制、语法、内存模型以及其带来的优势与潜在问题。

##### **4.1 继承的必要性与“is-a”关系**

1.  **必要性**
    *   **代码复用**：当多个类具有共同的属性和行为时，可以将这些共性提取到一个单独的类（父类）中。其他类（子类）通过继承这个父类，可以直接获得这些共有的成员，从而避免代码重复，提高开发效率。
    *   **建立层次结构**：继承是构建类层次结构的基础，能够清晰地表达现实世界中事物之间的分类关系（例如，“狗”是一种“动物”）。
    *   **可扩展性与可维护性**：通过继承，可以在不修改现有代码的基础上，创建新的类来扩展功能。当需要修改公共行为时，只需修改父类即可，所有子类都会自动继承这些变更。

2.  **“is-a”关系**
    *   继承的本质是表达一种 **“is-a”** （或 “is-a-kind-of”）的关系。如果可以说 “A is a B”，那么类A就可以继承自类B。
    *   **示例**：
        *   `UnderGraduate` **is a** `Student` (本科生是一种学生)
        *   `Lion` **is an** `Animal` (狮子是一种动物)
        *   `Carnivore` (食肉动物) **is an** `Animal`

##### **4.2 继承的实现：`extends`关键字**

*   **语法**：使用 `extends` 关键字来声明一个类继承自另一个类。

    ```java
    [修饰符] class 子类名 extends 父类名 {
        // ...
    }
    ```

*   **术语**：
    *   **父类 (Parent Class)**：被继承的类，也称为**超类 (Superclass)** 或**基类 (Base Class)**。
    *   **子类 (Subclass)**：继承父类的类，也称为**派生类 (Derived Class)**。

*   **Java的继承规则**：
    *   **单继承**：Java **不支持多重继承**，即一个类最多只能有一个直接父类。这是为了避免“钻石问题”（菱形继承问题），即当一个类继承的多个父类中有同名方法时，会产生调用歧义。
    *   **多层继承**：继承关系可以传递。例如，如果 `C` 继承 `B`，`B` 继承 `A`，那么 `C` 也会间接继承 `A` 的成员。
    *   **`Object` 类**：如果一个类没有显式地使用 `extends` 关键字继承任何类，那么它会**默认继承 `java.lang.Object` 类**。因此，`Object` 类是Java中所有类的最终祖先。

##### **4.3 `super`关键字：调用父类成员**

`super` 是一个关键字，用于在子类中引用其直接父类的成员。

1.  **调用父类的构造方法**
    *   **语法**：`super([参数列表]);`
    *   **作用**：在子类的构造方法中，调用父类的构造方法，以完成父类部分的初始化。
    *   **规则**：
        *   `super(...)` 必须是子类构造方法中的**第一条可执行语句**。
        *   如果子类构造方法中没有显式调用 `super(...)` 或 `this(...)`，编译器会自动插入一个对父类无参构造方法 `super()` 的调用。
        *   如果父类没有无参构造方法，子类构造方法必须显式调用父类的某个有参构造方法。

2.  **访问父类的成员**
    *   **语法**：`super.成员变量` 或 `super.成员方法()`
    *   **作用**：当子类中定义了与父类同名的成员（变量隐藏或方法覆盖）时，可以使用 `super` 关键字来明确地访问父类中的版本。

    ```java
    public class Lion extends Animal {
        private String type = "Lion"; // 隐藏了父类的 type 变量
    
        public String getSuperType() {
            return super.type; // 访问父类的 type 变量
        }
    
        @Override
        public void eat() {
            super.eat(); // 调用父类的 eat 方法
            System.out.println("... and it's a lion eating.");
        }
    }
    ```

##### **4.4 方法覆盖（Override）与变量隐藏**

1.  **方法覆盖 (Method Overriding)**
    *   **定义**：子类可以提供一个与父类中某个方法具有**相同方法签名**（方法名、参数列表）和**兼容返回类型**的新实现。
    *   **规则**：
        1.  方法签名必须完全相同。
        2.  子类方法的**访问权限不能低于**父类方法的访问权限（例如，父类是 `protected`，子类可以是 `protected` 或 `public`，但不能是 `private`）。
        3.  子类方法的返回值类型必须与父类方法的返回值类型相同，或者是其子类（协变返回类型）。
        4.  `private`、`static` 和 `final` 方法不能被覆盖。
    *   **`@Override` 注解**：这是一个编译器注解，用于声明该方法意图覆盖父类的方法。如果父类中没有可被覆盖的对应方法，编译器会报错。强烈建议使用此注解。

2.  **变量隐藏 (Variable Hiding)**
    *   **定义**：如果子类声明了一个与父类中同名的成员变量，那么子类的变量会**隐藏**父类的变量。
    *   **行为**：
        *   在子类内部，直接访问该变量名会引用子类的变量。要访问父类的变量，必须使用 `super.变量名`。
        *   **与方法覆盖不同**：变量访问的决定是在**编译时**根据引用的类型确定的，而不是在运行时根据对象的实际类型确定。

    ```java
    class Parent { int num = 5; }
    class Kid extends Parent { int num = 6; }
    
    public class Test {
        public static void main(String[] args) {
            Parent p = new Kid();
            System.out.println(p.num); // 输出 5，因为引用 p 的类型是 Parent
        }
    }
    ```

##### **4.5 子类构造过程**

1.  **调用顺序**：
    *   当创建一个子类对象时，会首先调用其父类的构造方法，然后才执行子类自己的构造方法。这个过程会沿着继承链一直上溯到 `Object` 类。
    *   **目的**：确保在子类对象被初始化之前，其所有父类部分都已经被正确初始化。

2.  **`super()` 的隐式与显式调用**：
    *   **隐式调用**：如果子类构造方法的第一行没有 `this(...)` 或 `super(...)`，编译器会自动插入 `super()`。
    *   **显式调用**：如果父类没有无参构造方法，子类必须在其构造方法的第一行显式调用 `super(参数)` 来匹配父类的某个构造方法。

    ```java
    public class Deer extends Animal {
        public Deer(String name) {
            super(name); // 显式调用父类的有参构造方法
            System.out.println("Deer's constructor is running");
        }
    }
    ```

##### **4.6 `final`关键字在继承中的应用**

*   **`final` 类**：
    *   **定义**：使用 `final` 修饰的类不能被继承。
    *   **用途**：当一个类的设计已经完整，不希望或不应该有任何子类时。例如，`java.lang.String` 类就是 `final` 的。

*   **`final` 方法**：
    *   **定义**：使用 `final` 修饰的方法不能被子类覆盖。
    *   **用途**：确保方法的核心逻辑在所有子类中保持不变。

##### **4.7 继承的利弊与组合/聚合关系**

1.  **继承的优点**：
    *   代码复用。
    *   建立清晰的层次结构。
    *   为多态提供了基础。

2.  **继承的缺点（谨慎使用继承）**：
    *   **强耦合关系**：子类与父类的实现紧密耦合。父类的任何改变都可能影响到所有子类，破坏子类的功能。
    *   **破坏封装性**：子类可以访问父类的 `protected` 成员，这在一定程度上破坏了父类的封装。
    *   **继承层次过深**：过于复杂的继承树会使系统难以理解和维护。

3.  **组合/聚合 (Composition/Aggregation)**
    *   **定义**：一个类将另一个类的对象作为其成员变量，这是一种 **“has-a”** 关系。
    *   **优势**：
        *   **松耦合**：类之间通过接口交互，而不是实现细节。
        *   **灵活性**：可以在运行时动态地改变被组合的对象。
        *   **维护封装**：不会破坏被组合对象的封装性。
    *   **原则**：**“组合优于继承” (Composition over Inheritance)**。在设计时，应优先考虑使用组合来实现代码复用和功能扩展，只有在确实存在明确的“is-a”关系时才使用继承。

好的，我们继续。以下是笔记的第二部分，第5章的详细内容。

---

### **Java面向对象编程高级笔记**

---

#### **第二部分：面向对象三大核心特性详解** (续)

---

#### **第5章：多态：统一接口与多样实现**

多态是面向对象编程中最核心、最强大的特性之一。它允许我们以统一的方式处理不同类型的对象，从而编写出更通用、灵活和可扩展的代码。本章将深入探讨多态的实现机制、抽象类与接口在实现多态中的关键作用。

##### **5.1 多态的必要性与核心思想**

1.  **必要性**
    *   **代码的可扩展性**：如果没有多态，当系统中增加新的子类型时，往往需要修改大量现有代码（例如，在`if-else`或`switch`语句中增加新的分支）。多态允许系统在不修改现有代码的情况下，无缝地接纳和处理新的子类型，这符合**开闭原则**（对扩展开放，对修改关闭）。
    *   **代码的通用性与简化**：多态允许我们编写一个方法，其参数类型是父类或接口，该方法就可以接受任何其子类或实现类的对象。这避免了为每一种具体类型编写重载方法，使代码更简洁、通用。

2.  **核心思想**
    *   **定义**：同一行为，作用于不同的对象，可以产生不同的执行结果。或者说，同一个接口，使用不同的实例而执行不同的操作。
    *   **本质**：**编译时类型**和**运行时类型**的不一致。
        *   **编译时类型**：由引用变量声明时使用的类型决定。
        *   **运行时类型**：由实际赋给该引用变量的对象类型决定。
    *   **动态绑定 (Dynamic Binding)**：当通过父类引用调用一个被子类覆盖的方法时，程序在**运行时**才根据该引用所指向的**实际对象类型**来决定调用哪个版本的方法。

##### **5.2 多态的实现条件**

在Java中，实现多态必须满足以下三个条件，缺一不可：

1.  **继承 (Inheritance)**：必须存在子类对父类的继承关系（或类对接口的实现关系）。
2.  **方法覆盖 (Method Overriding)**：子类必须重写父类的方法。
3.  **向上转型 (Upcasting)**：必须使用父类（或接口）的引用指向子类（或实现类）的对象。

**示例**：

```java
// 1. 继承
abstract class Animal {
    abstract void cry();
}
class Dog extends Animal {
    @Override // 2. 方法覆盖
    void cry() {
        System.out.println("汪汪...");
    }
}
class Cat extends Animal {
    @Override // 2. 方法覆盖
    void cry() {
        System.out.println("喵喵...");
    }
}

public class Test {
    public static void main(String[] args) {
        // 3. 向上转型
        Animal animal1 = new Dog(); 
        Animal animal2 = new Cat();

        // 多态的体现：同一个方法调用，行为不同
        animal1.cry(); // 运行时调用 Dog 的 cry()，输出 "汪汪..."
        animal2.cry(); // 运行时调用 Cat 的 cry()，输出 "喵喵..."
    }
}
```

##### **5.3 向上转型（Upcasting）与向下转型（Downcasting）**

1.  **向上转型 (Upcasting)**
    *   **定义**：将一个子类类型的引用赋值给一个父类类型的引用。这是自动发生的，无需强制类型转换。
    *   **语法**：`父类类型 引用名 = new 子类类型();`
    *   **效果**：
        *   通过父类引用，可以调用父类中定义的所有方法和变量。
        *   如果调用的方法在子类中被**覆盖**，则实际执行的是子类中的版本（动态绑定）。
        *   **限制**：通过父类引用，**不能**调用子类中**新增**的（父类没有的）方法和变量。

2.  **向下转型 (Downcasting)**
    *   **定义**：将一个父类类型的引用强制转换为一个子类类型的引用。
    *   **语法**：`子类类型 引用名 = (子类类型) 父类引用;`
    *   **目的**：为了调用子类中特有的（新增的）方法或访问其特有变量。
    *   **风险**：向下转型是不安全的。如果父类引用实际指向的对象不是目标子类类型（或其子类），在运行时会抛出 `ClassCastException` 异常。

##### **5.4 `instanceof`操作符**

为了安全地进行向下转型，需要先判断对象的实际类型。`instanceof` 操作符用于此目的。

*   **语法**：`引用变量 instanceof 类型`
*   **作用**：判断 `引用变量` 指向的对象是否是 `类型` 的一个实例（或者是其子类的实例）。如果是，返回 `true`；否则，返回 `false`。

**安全向下转型示例**：

```java
public void playSound(Animal animal) {
    animal.cry(); // 调用共性方法

    // 如果是狗，则调用其特有方法
    if (animal instanceof Dog) {
        Dog dog = (Dog) animal; // 安全的向下转型
        dog.lookHome();
    }
}
```

##### **5.5 抽象类与抽象方法 (`abstract`)**

1.  **抽象方法**
    *   **定义**：只有方法声明，没有方法体的方法，使用 `abstract` 关键字修饰。
    *   **语法**：`[修饰符] abstract 返回值类型 方法名([参数列表]);`
    *   **目的**：强制子类必须实现（覆盖）这个方法，提供具体的行为。

2.  **抽象类**
    *   **定义**：包含一个或多个抽象方法的类，必须使用 `abstract` 关键字声明。
    *   **特性**：
        *   **不能被实例化**：不能使用 `new` 关键字创建抽象类的对象。
        *   可以包含成员变量、普通方法和构造方法。
        *   抽象类的构造方法不能用于创建对象，但用于被子类构造方法调用（通过 `super()`）。
        *   如果一个类继承了抽象类，它必须实现（覆盖）父类中所有的抽象方法；否则，该子类也必须声明为抽象类。

##### **5.6 接口 (`interface`)：定义行为契约**

1.  **定义**
    *   接口是一种**纯粹的抽象**，它定义了一组行为的规范或契约，但不提供任何实现。
    *   使用 `interface` 关键字声明。

2.  **接口的成员**
    *   **方法**：接口中的所有方法默认都是 `public abstract` 的（可以省略这些关键字）。
    *   **变量**：接口中的所有变量默认都是 `public static final` 的（常量），必须在声明时初始化。

3.  **实现接口**
    *   一个类可以使用 `implements` 关键字来实现一个或多个接口。
    *   **规则**：
        *   一个类可以实现**多个接口**，这弥补了Java单继承的不足。
        *   一个类必须实现其声明的所有接口中的**全部抽象方法**；否则，该类必须声明为抽象类。

**接口示例**：

```java
public interface Flyer {
    void takeOff(); // 默认 public abstract
    void fly();
}

public class Bird implements Flyer {
    @Override
    public void takeOff() { /* ... */ }
    @Override
    public void fly() { /* ... */ }
}
```

##### **5.7 抽象类与接口的对比**

| 特性          | 抽象类 (`abstract class`)                                 | 接口 (`interface`)                                           |
| :------------ | :-------------------------------------------------------- | :----------------------------------------------------------- |
| **本质**      | 是一个**类**，表示“is-a”关系，强调所属关系。              | 是一个**行为契约**，表示“has-a”或“can-do”关系，强调能力。    |
| **继承/实现** | 子类使用 `extends` 继承，**单继承**。                     | 实现类使用 `implements` 实现，**多实现**。                   |
| **成员变量**  | 可以有各种类型的成员变量（`static`, `final`, 普通变量）。 | 只能有 `public static final` 类型的常量。                    |
| **成员方法**  | 可以有抽象方法和**具体方法**（有方法体）。                | 只能有 `public abstract` 方法（Java 8后可有默认方法和静态方法）。 |
| **构造方法**  | 有构造方法，用于子类初始化。                              | **没有**构造方法。                                           |
| **设计目的**  | 对一类事物的共同特征进行抽象，代码复用。                  | 定义不同类之间需要遵守的行为规范，实现解耦。                 |

**选择原则**：
*   当需要表示一种“is-a”关系，并且希望在父类中提供一些公共实现时，使用**抽象类**。
*   当需要定义一组不相关的类需要共同遵守的行为规范，或者希望利用Java的多实现特性时，使用**接口**。

好的，我们继续。以下是笔记的第三部分，第6章的详细内容。

---

### **Java面向对象编程高级笔记**

---

#### **第三部分：高级类特性与设计模式**

---

#### **第6章：高级类特性**

本章将探讨Java中一些更高级的类特性，包括`static`关键字、代码块、内部类以及所有类的根`Object`类。理解这些特性对于编写更高效、结构更清晰的Java代码至关-要。

##### **6.1 `static`关键字：类变量与类方法**

`static`关键字用于修饰类的成员（变量和方法），使其属于**类本身**而不是类的某个具体实例。

1.  **静态变量 (Static Variables / Class Variables)**
    *   **定义**：使用 `static` 修-的成员变量。
    *   **内存分配**：静态变量存储在内存的**方法区**（或称为元空间）中，并且在类加载时就被分配空间和初始化，**只存在一份**。
    *   **生命周期**：与类共存亡。从类被加载到虚拟机卸载该类为止。
    *   **共享性**：被该类的所有实例**共享**。任何一个对象修改了静态变量的值，其他所有对象访问到的都是修改后的值。
    *   **访问方式**：
        *   通过类名直接访问：`类名.静态变量` (推荐方式)
        *   通过对象引用访问：`对象引用.静态变量` (不推荐，易引起混淆)

2.  **静态方法 (Static Methods / Class Methods)**
    *   **定义**：使用 `static` 修饰的成员方法。
    *   **特性**：
        *   静态方法属于类，不依赖于任何对象实例，因此可以通过**类名直接调用**。
        *   在静态方法内部，**不能直接访问**非静态的成员变量或调用非静态方法，因为非静态成员必须依赖于具体的对象实例。
        *   在静态方法内部，**不能使用 `this` 或 `super`** 关键字，因为它们都指向具体的对象实例。
        *   静态方法可以访问静态变量和调用其他静态方法。
    *   **应用场景**：
        *   **工具类方法**：当一个方法的功能不依赖于任何对象的状态时，可以定义为静态方法，如 `java.lang.Math` 类中的所有方法。
        *   **主方法 `main`**：`main` 方法必须是 `public static` 的，以便JVM在不创建任何对象的情况下启动程序。

**示例**：统计创建的对象数量

```java
public class People {
    // 实例变量，每个对象独有一份
    private String name;
    
    // 静态变量，所有对象共享
    public static int count = 0;

    public People(String name) {
        this.name = name;
        count++; // 每创建一个对象，count自增
    }
}

public class Test {
    public static void main(String[] args) {
        System.out.println("Initial count: " + People.count); // 输出 0
        People p1 = new People("Tom");
        People p2 = new People("Mary");
        System.out.println("Final count: " + People.count); // 输出 2
    }
}
```

##### **6.2 静态代码块与实例代码块**

代码块是用 `{}` 包围的一段代码，根据有无 `static` 关键字分为静态代码块和实例代码块。

1.  **静态代码块 (Static Initializer Block)**
    *   **语法**：`static { ... }`
    *   **执行时机**：在**类加载时**执行，且**仅执行一次**。
    *   **执行顺序**：在 `main` 方法执行之前，在构造方法执行之前。如果一个类有多个静态代码块，它们将按照在代码中出现的顺序依次执行。
    *   **作用**：通常用于初始化静态变量或执行一些类级别的预处理操作。

2.  **实例代码块 (Instance Initializer Block)**
    *   **语法**：`{ ... }`
    *   **执行时机**：在**每次创建对象时**执行。
    *   **执行顺序**：在**构造方法主体执行之前**，但在父类构造方法执行之后。
    *   **作用**：用于提取多个构造方法中的公共初始化代码。

**执行顺序总结**：
当创建一个子类对象时，初始化顺序如下：
1.  父类静态变量初始化 / 父类静态代码块
2.  子类静态变量初始化 / 子类静态代码块
3.  父类实例变量初始化 / 父类实例代码块
4.  父类构造方法
5.  子类实例变量初始化 / 子类实例代码块
6.  子类构造方法

##### **6.3 内部类 (Inner Classes)**

内部类是定义在另一个类内部的类。它提供了一种更好的封装方式，并能方便地访问外部类的成员。

1.  **成员内部类 (Member Inner Class)**
    *   **定义**：作为外部类的一个成员，与成员变量和成员方法地位相同。
    *   **特性**：
        *   可以访问外部类的所有成员，包括 `private` 成员。
        *   成员内部类的实例**必须依赖于**外部类的实例而存在。创建内部类实例前，必须先创建外部类实例。
        *   语法：`OuterClass.InnerClass innerObj = outerObj.new InnerClass();`

2.  **静态内部类 (Static Nested Class)**
    *   **定义**：使用 `static` 关键字修饰的内部类。
    *   **特性**：
        *   不依赖于外部类的实例，可以独立创建。语法：`OuterClass.StaticInnerClass innerObj = new OuterClass.StaticInnerClass();`
        *   只能访问外部类的**静态**成员。
        *   可以拥有静态成员，而成员内部类不能。

3.  **局部内部类 (Local Inner Class)**
    *   **定义**：定义在方法或代码块内部的类。
    *   **特性**：
        *   作用域仅限于其所在的方法或代码块。
        *   可以访问外部类的所有成员。
        *   可以访问其所在方法中的**final**或**effectively final**（事实上的final，即初始化后未被修改）的局部变量。

4.  **匿名内部类 (Anonymous Inner Class)**
    *   **定义**：没有名字的局部内部类，通常用于简化代码，尤其是在事件处理和创建线程时。
    *   **语法**：`new 父类名/接口名() { // 类的实现 }`
    *   **特性**：
        *   必须继承一个类或实现一个接口。
        *   不能定义任何静态成员或静态方法。
        *   不能有构造方法，但可以通过实例初始化块来完成初始化。

    **示例**（事件监听器）：
    ```java
    button.addActionListener(new ActionListener() {
        @Override
        public void actionPerformed(ActionEvent e) {
            System.out.println("Button clicked!");
        }
    });
    ```

##### **6.4 `Object`类：所有类的根**

`java.lang.Object` 类是Java类层次结构的根。所有类都直接或间接地继承自 `Object` 类。它提供了一些所有对象都应具备的基本方法。

*   **`toString()`**：返回对象的字符串表示。默认实现是 `getClass().getName() + "@" + Integer.toHexString(hashCode())`。
*   **`equals(Object obj)`**：比较两个对象是否“相等”。默认实现是比较两个引用是否指向同一个内存地址（等同于 `==`）。通常需要根据业务逻辑重写此方法，以比较对象的内容。
*   **`hashCode()`**：返回对象的哈希码值。`equals()` 和 `hashCode()` 之间有严格的约定：如果两个对象通过 `equals()` 方法比较是相等的，那么它们的 `hashCode()` 必须相同。
*   **`getClass()`**：返回对象的运行时类 (`Class` 对象)。
*   **`finalize()`**：在对象被垃圾回收前调用。
*   **`wait()`, `notify()`, `notifyAll()`**：用于线程间的通信。

##### **6.5 `equals()`方法与`==`操作符的区别**

这是一个非常重要的概念，也是面试中的常见问题。

1.  **`==` 操作符**
    *   **作用于基本数据类型**：比较的是它们的**值**是否相等。
    *   **作用于引用数据类型**：比较的是两个引用变量是否指向**同一个内存地址**（即是否为同一个对象）。

2.  **`equals()` 方法**
    *   **来源**：`Object` 类的一个方法。
    *   **`Object` 类的默认实现**：与 `==` 操作符完全相同，比较的是对象的内存地址。
    *   **重写**：许多类（如 `String`, `Integer`, `Date`）都重写了 `equals()` 方法，以实现**内容**的比较。例如，`String` 类的 `equals()` 方法比较的是两个字符串的字符序列是否相同。

**总结**：

*   对于基本类型，只能用 `==` 比较值。
*   对于引用类型，`==` 总是比较内存地址。
*   对于引用类型，`equals()` 的行为取决于该类是否重写了此方法。未重写时与 `==` 相同；重写后通常用于比较对象的内容。

**示例**：

```java
String str1 = new String("Hello");
String str2 = new String("Hello");
String str3 = str1;

System.out.println(str1 == str2);      // false (两个不同的对象)
System.out.println(str1.equals(str2)); // true (内容相同)
System.out.println(str1 == str3);      // true (指向同一个对象)
```

---

#### **第7章：面向对象设计原则与设计模式**

本章是从代码编写者向软件设计者进阶的关键。我们将系统性地学习指导高质量软件设计的核心原则，这些原则是无数项目经验的总结，旨在构建可维护、可扩展、可复用、健壮且灵活的软件系统。随后，我们将深入探讨几种最基本且至关重要的设计模式，它们是针对特定设计问题的、经过反复验证的“标准答案”，掌握它们能极大地提升代码质量和设计能力。

##### **7.1 核心设计原则**

这些原则并非孤立存在，而是相辅相成，共同构成了现代面向对象设计的思想基石。

1.  **高内聚，低耦合 (High Cohesion, Low Coupling)**
    *   **高内聚 (High Cohesion)**：
        *   **定义**：一个模块（或一个类）的内部，其所有组成元素（属性、方法）应该紧密地围绕一个单一的核心职责来组织。这些元素彼此之间高度相关，共同完成一项明确的任务。
        *   **衡量**：一个类如果需要经常同时修改其多个方法，或者其方法操作的数据关联性不强，那么它的内聚性就较低。
        *   **目的**：使得类的职责清晰、功能专一，易于理解和维护。
    *   **低耦合 (Low Coupling)**：
        *   **定义**：模块与模块（或类与类）之间的依赖关系应该尽可能地弱。一个模块的内部实现变化，不应该影响到依赖于它的其他模块。
        *   **衡量**：如果修改一个类，导致需要修改大量其他相关的类，那么系统耦合度就很高。
        *   **目的**：提高模块的独立性和可复用性，降低系统维护成本，使得系统各部分可以独立演化。

2.  **SOLID原则**
    *   **S - 单一职责原则 (Single Responsibility Principle - SRP)**
        *   **定义**：**A class should have only one reason to change.** (一个类应该只有一个引起它变化的原因)。这意味着一个类应该只封装一种类型的职责。
        *   **深度解析**：“职责”的划分是关键，它是一个业务或功能层面的概念。如果一个类承担了过多的职责，当其中一个职责发生变化时，可能会影响到其他职责的实现，导致类的稳定性下降。
        *   **示例**：一个`User`类既负责用户信息的存储（属性），又负责用户数据的数据库持久化（`saveToDB()`），还负责将用户信息展示为JSON（`toJSON()`）。这违反了SRP。更好的设计是将其拆分为`User`（数据模型）、`UserRepository`（持久化）和`UserView`（视图展示）三个类。

    *   **O - 开闭原则 (Open/Closed Principle - OCP)**
        *   **定义**：**Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.** (软件实体应该对扩展开放，对修改关闭)。
        *   **深度解析**：这是面向对象设计的核心原则。当需要增加新功能时，我们应该通过增加新的代码（如新的子类、新的实现类）来实现，而不是去修改已有的、经过测试的稳定代码。
        *   **实现方式**：主要通过**抽象**来实现。定义稳定的抽象层（抽象类或接口），将易变的部分封装在具体的实现类中。当需求变化时，只需创建新的实现类，而无需修改依赖于抽象的客户端代码。

    *   **L - 里氏替换原则 (Liskov Substitution Principle - LSP)**
        *   **定义**：**Subtypes must be substitutable for their base types.** (子类型必须能够替换掉它们的基类型)。即在任何使用父类对象的地方，都可以用其子类对象来替换，并且程序的行为不会产生任何错误或异常。
        *   **深度解析**：这是对继承关系的约束。它强调子类只能**扩展**父类的功能，而不能**改变**父类原有的行为约定。如果子类覆盖了父类的方法，但其实现违背了父类方法的意图（例如，前置条件更苛刻，后置条件更宽松），就会违反LSP。
        *   **示例**：一个`resize(Rectangle r)`方法，期望传入的矩形`r`在`setWidth`后，`getWidth`能得到设置的值。如果传入一个`Square`（正方形）的子类对象，其`setWidth`方法同时修改了`height`，这可能会破坏`resize`方法的内部逻辑，导致不可预期的行为。

    *   **I - 接口隔离原则 (Interface Segregation Principle - ISP)**
        *   **定义**：**Clients should not be forced to depend upon interfaces that they do not use.** (客户端不应该被强迫依赖于它们不使用的方法)。
        *   **深度解析**：提倡创建小而专一的接口，而不是大而全的“胖接口”。如果一个接口包含了多个客户端可能不需要的方法，那么实现该接口的类将被迫实现这些无用的方法，增加了不必要的复杂性和耦合。
        *   **示例**：一个`Pet`接口有`playBall()`, `climbTree()`, `catchMouse()`三个方法。`Dog`类实现了`Pet`接口，但`Dog`不会爬树和抓老鼠，却必须实现这两个空方法。更好的设计是将其拆分为`Playable`, `Climbable`, `Catchable`等更小的接口，类按需实现。

    *   **D - 依赖倒置原则 (Dependency Inversion Principle - DIP)**
        *   **定义**：
            1.  **High-level modules should not depend on low-level modules. Both should depend on abstractions.** (高层模块不应依赖于底层模块，两者都应依赖于抽象。)
            2.  **Abstractions should not depend on details. Details should depend on abstractions.** (抽象不应依赖于细节，细节应依赖于抽象。)
        *   **深度解析**：这是实现系统解耦的根本。传统的结构化编程是高层调用低层，是高层依赖低层。依赖倒置则是通过引入抽象层（接口或抽象类），使得高层模块和底层模块都只依赖于这个抽象层，从而实现了它们之间的解耦。这就是“**面向接口编程**”的核心思想。
        *   **示例**：一个`Car`类直接依赖于一个具体的`GasolineEngine`类。这违反了DIP。更好的设计是定义一个`Engine`接口，让`Car`类依赖于`Engine`接口，而`GasolineEngine`和`ElectricEngine`都去实现这个接口。这样，更换引擎时无需修改`Car`类的代码。

3.  **迪米特法则 (Law of Demeter - LoD) / 最少知识原则**
    *   **定义**：**Talk only to your immediate friends.** (只与你的直接朋友交谈)。
    *   **深度解析**：一个对象的方法应该只调用：
        1.  该对象自身的方法。
        2.  传入该方法的参数对象的方法。
        3.  该方法内部创建的对象的方法。
        4.  该对象的成员变量对象的方法。
    *   **目的**：减少类之间的耦合。如果一个类通过一系列的`get`方法调用深入到另一个对象的内部结构中（如 `a.getB().getC().doSomething()`），就形成了紧密的耦合链，违反了LoD。应该由直接朋友提供所需的服务，而不是暴露其内部结构。

##### **7.2 设计模式概述**

*   **定义**：设计模式（Design Pattern）是在特定上下文中，针对常见软件设计问题的一种经过验证的、可复用的解决方案。它不是一个可以直接转换成代码的成品，而是一种描述问题、解决方案、何时应用该方案以及其后果的模板。
*   **分类**：
    1.  **创建型模式 (Creational Patterns)**：核心在于**对象的创建**。它们将对象的创建过程与使用过程解耦，使得系统在创建什么对象、如何创建、何时创建等方面更具灵活性。
    2.  **结构型模式 (Structural Patterns)**：核心在于**类和对象的组合**。它们描述了如何将类或对象组合成更大的结构，以实现新的功能，同时保持结构的灵活性和效率。
    3.  **行为型模式 (Behavioral Patterns)**：核心在于**对象间的交互和职责分配**。它们描述了对象之间如何有效地通信和协作，以完成单个对象无法独立完成的任务。

##### **7.3 创建型模式**

1.  **单例模式 (Singleton Pattern)**
    *   **意图**：保证一个类仅有一个实例，并提供一个全局访问点来访问它。
    *   **应用场景**：需要全局唯一实例的场景，如配置文件管理器、线程池、日志对象等。
    *   **实现要点**：
        1.  **私有化构造方法**：`private Singleton() {}`，杜绝外部通过 `new` 自由创建实例。
        2.  **静态私有实例变量**：`private static Singleton instance;`，用于持有唯一的实例。
        3.  **公共静态获取方法**：`public static Singleton getInstance() { ... }`，作为全局唯一的访问点。
    *   **实现方式详解**：
        *   **饿汉式**：在类加载时就完成实例化。
            ```java
            public class Singleton {
                private static final Singleton INSTANCE = new Singleton();
                private Singleton() {}
                public static Singleton getInstance() {
                    return INSTANCE;
                }
            }
            ```
            *   **优点**：实现简单，天生线程安全（由JVM类加载机制保证）。
            *   **缺点**：无论是否使用，实例都会被创建，可能造成资源浪费。

        *   **懒汉式（线程不安全）**：在第一次调用`getInstance()`时才创建实例。
            ```java
            public class Singleton {
                private static Singleton instance;
                private Singleton() {}
                public static Singleton getInstance() {
                    if (instance == null) {
                        instance = new Singleton();
                    }
                    return instance;
                }
            }
            ```
            *   **优点**：实现了延迟加载。
            *   **缺点**：在多线程环境下，可能创建多个实例，线程不安全。

        *   **懒汉式（线程安全 - 同步方法）**：
            ```java
            public static synchronized Singleton getInstance() { ... }
            ```
            *   **优点**：线程安全。
            *   **缺点**：每次调用`getInstance()`都需要同步，性能开销大。

2.  **工厂模式 (Factory Pattern)**
    *   **意图**：将对象的创建逻辑封装起来，客户端只需向工厂请求所需的对象，而无需关心具体的创建过程。
    *   **简单工厂模式 (Simple Factory)**
        *   **结构**：一个工厂类，内部有一个静态方法，根据传入的参数（如字符串）通过`if-else`或`switch`来创建并返回不同的产品实例。
        *   **缺点**：违反开闭原则。每增加一个新产品，都需要修改工厂类的代码。

    *   **工厂方法模式 (Factory Method)**
        *   **结构**：定义一个抽象工厂接口（`Creator`），其中包含一个创建产品的抽象方法（`factoryMethod()`）。再定义一个抽象产品接口（`Product`）。具体的工厂类（`ConcreteCreator`）实现工厂接口，负责创建具体的产品（`ConcreteProduct`）。
        *   **优点**：完全符合开闭原则。增加新产品时，只需增加对应的具体产品类和具体工厂类，无需修改现有代码。将创建过程推迟到子类。

    *   **抽象工厂模式 (Abstract Factory)**
        *   **结构**：提供一个接口，用于创建**一系列相关或相互依赖的对象（一个产品族）**。例如，一个`GUIFactory`接口可以定义`createButton()`和`createTextField()`方法。`WindowsFactory`和`MacFactory`分别实现这个接口，创建出Windows风格和Mac风格的一套UI组件。
        *   **优点**：隔离了具体类的生成，保证了客户端使用的是同一产品族的对象。
        *   **缺点**：扩展新的产品等级结构困难（例如，想在`GUIFactory`中增加一个`createCheckbox()`方法，需要修改所有工厂实现类）。

##### **7.4 结构型模式**

1.  **适配器模式 (Adapter Pattern)**
    *   **意图**：将一个类的接口转换成客户端希望的另一个接口，使得原本接口不兼容的类可以协同工作。常用于集成遗留系统或第三方库。
    *   **角色**：
        *   **目标 (Target)**：客户端代码所依赖的接口。
        *   **被适配者 (Adaptee)**：已存在的、接口不符合`Target`的类。
        *   **适配器 (Adapter)**：实现`Target`接口，内部持有`Adaptee`的实例。在实现`Target`接口的方法时，调用`Adaptee`实例的相应方法来完成功能。

2.  **装饰器模式 (Decorator Pattern)**
    *   **意图**：在不改变原有对象结构和继承关系的前提下，动态地为对象添加新的功能。
    *   **结构**：
        *   **组件 (Component)**：定义一个抽象接口。
        *   **具体组件 (ConcreteComponent)**：实现该接口的原始对象，即被装饰者。
        *   **装饰器 (Decorator)**：也实现`Component`接口，并持有一个`Component`对象的引用（`has-a`关系）。
        *   **具体装饰器 (ConcreteDecorator)**：继承自`Decorator`，负责为组件添加具体的新功能。它可以在调用被装饰对象原有方法的前后，加上自己的新行为。

##### **7.5 行为型模式**

1.  **策略模式 (Strategy Pattern)**
    *   **意图**：定义一系列算法，将每个算法都封装起来，并使它们可以相互替换。策略模式让算法的变化独立于使用算法的客户。
    *   **结构**：
        *   **上下文 (Context)**：维护一个对`Strategy`对象的引用。它不实现具体的算法，而是将工作委托给当前的策略对象。
        *   **策略 (Strategy)**：定义所有支持算法的公共接口。
        *   **具体策略 (ConcreteStrategy)**：实现`Strategy`接口，封装了具体的算法实现。

2.  **观察者模式 (Observer Pattern)**
    *   **意图**：定义对象之间的一对多依赖关系，当一个对象（主题）的状态发生改变时，所有依赖于它的对象（观察者）都会得到通知并自动更新。
    *   **结构**：
        *   **主题 (Subject)**：提供注册、移除和通知观察者的方法。
        *   **观察者 (Observer)**：定义一个更新接口，供主题在状态改变时调用。
        *   **具体主题 (ConcreteSubject)**：维护自身状态，并在状态改变时通知所有注册的观察者。
        *   **具体观察者 (ConcreteObserver)**：实现更新接口，以响应主题的通知。

3.  **责任链模式 (Chain of Responsibility Pattern)**
    *   **意图**：避免请求发送者与接收者之间的耦合，让多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
    *   **结构**：
        *   **处理器 (Handler)**：定义一个处理请求的接口，并维护一个对后继处理器（链中的下一个对象）的引用。
        *   **具体处理器 (ConcreteHandler)**：实现`Handler`接口。它判断自己是否能处理该请求，如果能，则处理；如果不能，则将请求传递给它的后继者

#### **第9章：Java集合框架**

Java集合框架（Java Collections Framework, JCF）是一个强大而统一的体系结构，用于表示和操作对象的集合。它提供了一套精心设计的接口、实现类和算法，极大地简化了数据结构的使用。本章将全面介绍集合框架的核心概念、主要接口、泛型应用以及遍历方式。

##### **9.1 集合框架概述与核心接口**

1.  **概述**
    *   **定义**：集合框架是一个容器，专门用于存储对象的**引用**。它与数组不同，数组可以存储基本数据类型和对象引用，且长度固定；而集合只能存储对象引用，并且其大小通常是动态可变的。
    *   **位置**：所有集合相关的类和接口都位于`java.util`包下。
    *   **组成**：
        *   **接口 (Interfaces)**：定义了集合的抽象数据类型（ADT），如`List`, `Set`, `Map`。
        *   **实现类 (Implementations)**：接口的具体实现，提供了可用的数据结构，如`ArrayList`, `HashSet`, `HashMap`。
        *   **算法 (Algorithms)**：在集合上执行有用计算的方法，如排序、搜索，主要由`Collections`工具类提供。

2.  **核心接口体系**
    Java集合框架主要由两大根接口派生而来：`Collection` 和 `Map`。

    *   **`Collection`接口**：定义了操作**单个元素**集合的通用方法。它是`List`、`Set`和`Queue`接口的父接口。
        *   **`List`接口**：**有序**集合（也称为序列）。元素按插入顺序存储，可以包含**重复**元素。可以通过索引访问元素。
        *   **`Set`接口**：**无序**集合。不允许包含**重复**元素。
        *   **`Queue`接口**：队列。通常以先进先出（FIFO）的方式对元素进行排序。

    *   **`Map`接口**：存储**键值对 (key-value pairs)** 的集合。键（key）是唯一的，每个键映射到一个值（value）。它不继承自`Collection`接口。

    **结构图**：
    ```
    (Iterable)
       |
       | extends
       v
    Collection
       |-----------------|-----------------|
       | extends         | extends         | extends
       v                 v                 v
      List              Set               Queue
    
    Map
    ```

##### **9.2 泛型（Generics）的应用**

泛型是Java SE 5.0引入的一个关键特性，它为集合框架带来了**类型安全**和**代码简化**。

1.  **泛型的必要性**
    *   **类型不安全**：在没有泛型之前，集合中存储的所有对象都被视为`Object`类型。这意味着可以向同一个集合中添加任何类型的对象（如`String`, `Integer`）。
    *   **强制类型转换**：从集合中取出元素时，必须进行强制类型转换，这不仅繁琐，而且存在风险。如果在转换时类型不匹配，将在运行时抛出`ClassCastException`。

2.  **泛型的优势**
    *   **类型安全**：通过在创建集合时指定其可以容纳的元素类型（如 `List<String>`），编译器会在编译时检查放入集合的元素类型。如果尝试添加不兼容的类型，编译器会报错，将运行时错误提前到编译时。
    *   **消除强制类型转换**：从泛型集合中获取元素时，编译器知道其确切类型，因此无需进行强制类型转换，使代码更简洁、更安全。

**示例对比**：

*   **没有泛型**：
    ```java
    List list = new ArrayList();
    list.add("string");
    list.add(123); // 编译通过，但逻辑上可能不希望
    String s = (String) list.get(0); // 需要强转
    // String s2 = (String) list.get(1); // 运行时抛出 ClassCastException
    ```

*   **使用泛型**：
    ```java
    List<String> list = new ArrayList<>();
    list.add("string");
    // list.add(123); // 编译错误，类型不匹配
    String s = list.get(0); // 无需强转
    ```

##### **9.3 `Collection`接口：`List`与`Set`**

1.  **`List`接口**
    *   **特点**：有序、可重复。
    *   **常用实现类**：
        *   **`ArrayList`**：
            *   **底层实现**：基于**动态数组**。
            *   **性能**：**查询和随机访问（`get`）效率高**（时间复杂度O(1)），因为可以通过索引直接定位。**插入和删除效率低**（时间复杂度O(n)），尤其是在列表的开头或中间，因为需要移动后续所有元素。
            *   **适用场景**：读多写少的场景。
        *   **`LinkedList`**：
            *   **底层实现**：基于**双向链表**。
            *   **性能**：**插入和删除效率高**（时间复杂度O(1)），只需修改前后节点的指针。**查询和随机访问效率低**（时间复杂度O(n)），需要从头或尾开始遍历。
            *   **适用场景**：写多读少的场景，特别是频繁的插入和删除操作。

2.  **`Set`接口**
    *   **特点**：无序（通常）、不可重复。
    *   **唯一性保证**：`Set`通过元素的`equals()`和`hashCode()`方法来保证元素的唯一性。当添加一个新元素时，`Set`会检查集合中是否已存在一个与新元素`equals()`为`true`的元素。
    *   **常用实现类**：
        *   **`HashSet`**：
            *   **底层实现**：基于**哈希表 (HashMap)**。
            *   **性能**：添加、删除、查找操作的平均时间复杂度为**O(1)**，性能非常高。
            *   **顺序**：**不保证**元素的存储和迭代顺序。
            *   **null值**：允许存储一个`null`元素。
        *   **`TreeSet`**：
            *   **底层实现**：基于**红黑树 (Red-Black Tree)**。
            *   **性能**：添加、删除、查找操作的时间复杂度为**O(log n)**。
            *   **顺序**：元素是**有序**的。排序方式由元素的自然顺序（实现`Comparable`接口）或在创建`TreeSet`时提供的`Comparator`决定。
            *   **null值**：**不允许**存储`null`元素。

##### **9.4 `Map`接口**

*   **特点**：存储键值对，键唯一，值可重复。
*   **常用实现类**：
    *   **`HashMap`**：
        *   **底层实现**：基于**哈希表**（数组 + 链表/红黑树）。
        *   **性能**：添加、删除、查找（根据键）操作的平均时间复杂度为**O(1)**。
        *   **顺序**：**不保证**键值对的存储和迭代顺序。
        *   **null值**：允许一个`null`键和多个`null`值。
    *   **`TreeMap`**：
        *   **底层实现**：基于**红黑树**。
        *   **性能**：添加、删除、查找操作的时间复杂度为**O(log n)**。
        *   **顺序**：键是**有序**的，排序方式由键的自然顺序或`Comparator`决定。
        *   **null值**：**不允许**`null`键。
    *   **`Hashtable`**：
        *   **底层实现**：基于哈希表。
        *   **特性**：与`HashMap`类似，但是是**线程安全**的（方法被`synchronized`修饰），因此性能较低。
        *   **null值**：**不允许**`null`键和`null`值。现在已不推荐使用，通常由`ConcurrentHashMap`替代。

##### **9.5 迭代器（`Iterator`）**

*   **迭代器模式**：提供一种统一的方法来顺序访问一个聚合对象（集合）中的各个元素，而又不暴露其内部的表示。
*   **`Iterator`接口**：是Java中实现迭代器模式的核心。
    *   **获取方式**：所有`Collection`集合都提供了`iterator()`方法来获取一个`Iterator`实例。
    *   **核心方法**：
        *   `boolean hasNext()`：检查序列中是否还有下一个元素。
        *   `E next()`：返回序列中的下一个元素，并将迭代器向后移动。
        *   `void remove()`：从集合中移除`next()`方法最后返回的那个元素（可选操作）。

**遍历示例**：

```java
List<String> list = new ArrayList<>();
list.add("A");
list.add("B");

Iterator<String> it = list.iterator();
while (it.hasNext()) {
    String element = it.next();
    System.out.println(element);
}
```

*   **增强型`for`循环 (For-Each Loop)**：是迭代器模式的语法糖，使遍历代码更简洁。其底层实现就是通过`Iterator`。

```java
for (String element : list) {
    System.out.println(element);
}
```

##### **9.6 `Collections`工具类**

`java.util.Collections`是一个工具类，提供了大量用于操作或返回集合的**静态方法**。

*   **排序 (Sorting)**：`Collections.sort(List<T> list)`
*   **反转 (Reversing)**：`Collections.reverse(List<?> list)`
*   **混排 (Shuffling)**：`Collections.shuffle(List<?> list)`
*   **查找 (Searching)**：`Collections.binarySearch(...)`
*   **最值 (Extrema)**：`Collections.max(...)`, `Collections.min(...)`
*   **线程安全包装**：`Collections.synchronizedList(...)`, `Collections.synchronizedSet(...)`等，可以将非线程安全的集合包装成线程安全的。

##### **9.7 函数式编程与Lambda表达式入门**

Java 8引入了函数式编程特性，极大地简化了集合操作。

*   **Lambda表达式**：一种简洁的、用于表示匿名函数的方式。
    *   **语法**：`(parameters) -> expression` 或 `(parameters) -> { statements; }`
*   **Stream API**：一个强大的API，允许以声明式的方式处理集合数据。
    *   **核心操作**：
        *   **过滤 (filter)**：`list.stream().filter(s -> s.startsWith("c"))`
        *   **映射 (map)**：`list.stream().map(String::toUpperCase)`
        *   **排序 (sorted)**：`list.stream().sorted()`
        *   **遍历 (forEach)**：`list.stream().forEach(System.out::println)`

**示例**：

```java
List<String> list = Arrays.asList("a1", "c2", "b1", "c1");

list.stream()
    .filter(s -> s.startsWith("c")) // 找到以 'c' 开头的元素
    .map(String::toUpperCase)        // 将它们转换为大写
    .sorted()                        // 排序
    .forEach(System.out::println);   // 打印
// 输出:
// C1
// C2
```

好的，我们继续。以下是笔记的第四部分，第10章的详细内容。

---

### **Java面向对象编程高级笔记**

---

#### **第四部分：Java核心API与高级应用** (续)

---

#### **第10章：多线程程序设计**

多线程是现代编程中不可或缺的一部分，它允许程序同时执行多个任务，从而提高CPU利用率和应用程序的响应性。本章将系统地介绍进程与线程的概念、Java中线程的生命周期与状态转换、线程的创建与启动方式，并重点探讨多线程编程中的核心挑战：线程同步与通信。

##### **10.1 进程与线程的概念**

1.  **程序 (Program)**
    *   **定义**：存储在磁盘上的一段**静态**的代码和数据集合，是应用程序执行的蓝本。

2.  **进程 (Process)**
    *   **定义**：程序的一次**动态**执行过程。是操作系统进行资源分配和调度的基本单位。
    *   **特性**：
        *   **独立性**：每个进程都拥有自己独立的内存地址空间、数据栈以及其他系统资源（如文件句柄）。
        *   **隔离性**：一个进程的崩溃通常不会直接影响到其他进程。
        *   **资源开销**：进程的创建、销毁和切换（上下文切换）涉及大量的系统资源，开销较大。

3.  **线程 (Thread)**
    *   **定义**：进程内的一个单一顺序的控制流，是CPU调度的**最小单位**。一个进程可以包含一个或多个线程。
    *   **特性**：
        *   **轻量级**：线程的创建和切换开销远小于进程。
        *   **资源共享**：同一进程内的所有线程共享该进程的内存空间（代码区、数据区、堆）和系统资源。
        *   **私有资源**：每个线程拥有自己独立的程序计数器、虚拟机栈和本地方法栈。
    *   **多线程 (Multi-threading)**：指在一个进程中同时运行多个线程，以执行不同的任务，实现并发。

##### **10.2 线程的生命周期与状态**

一个Java线程在其生命周期中会经历以下几种状态：

1.  **新建 (NEW)**
    *   **描述**：当使用`new`关键字创建了一个`Thread`对象后，该线程就处于新建状态。此时，它仅仅是一个Java对象，操作系统尚未为其分配资源。

2.  **就绪 (RUNNABLE)**
    *   **描述**：当线程对象调用了`start()`方法后，线程进入就绪状态。此时，线程已经具备了运行的所有条件，位于“可运行线程池”中，等待CPU调度器分配执行时间片。
    *   **注意**：Java虚拟机规范中将“就绪”和“运行中”统称为`RUNNABLE`状态。

3.  **运行 (RUNNING)**
    *   **描述**：处于就绪状态的线程获得了CPU时间片，开始执行其`run()`方法中的代码。

4.  **阻塞 (BLOCKED / WAITING / TIMED_WAITING)**
    *   **描述**：线程因某种原因暂时放弃CPU使用权，停止执行，进入阻塞状态，直到阻塞条件解除后才会重新回到就绪状态。
    *   **导致阻塞的原因**：
        *   **`BLOCKED`**：线程等待获取一个`synchronized`同步锁。
        *   **`WAITING`**：线程调用了`Object.wait()`、`Thread.join()`或`LockSupport.park()`等方法，无限期等待另一个线程的特定操作（如`notify()`或`unpark()`）。
        *   **`TIMED_WAITING`**：线程调用了带有超时参数的方法，如`Thread.sleep(long millis)`、`Object.wait(long timeout)`、`Thread.join(long millis)`等，在指定时间后会自动返回就绪状态。

5.  **终止 (TERMINATED)**
    *   **描述**：线程的`run()`方法执行完毕或因未捕获的异常而退出，线程生命周期结束。

**状态转换图**：
`NEW` -> `start()` -> `RUNNABLE` <-> `CPU调度` <-> `RUNNING`
`RUNNING` -> `阻塞事件` -> `BLOCKED/WAITING/TIMED_WAITING`
`BLOCKED/WAITING/TIMED_WAITING` -> `唤醒/超时/获取锁` -> `RUNNABLE`
`RUNNING` -> `run()结束/异常` -> `TERMINATED`

##### **10.3 线程的创建与启动方式**

Java提供了两种主要的方式来创建线程：

1.  **继承 `Thread` 类**
    *   **步骤**：
        1.  创建一个类，继承自`java.lang.Thread`。
        2.  重写（Override）`run()`方法，将线程需要执行的任务逻辑放在`run()`方法中。
        3.  创建该子类的实例。
        4.  调用实例的`start()`方法来启动线程。
    *   **示例**：
        ```java
        class MyThread extends Thread {
            @Override
            public void run() {
                System.out.println("Thread is running...");
            }
        }
        // 启动
        MyThread t = new MyThread();
        t.start(); // 注意是调用 start() 而不是 run()
        ```
    *   **缺点**：Java是单继承的，如果类已经继承了其他类，就无法再继承`Thread`类。

2.  **实现 `Runnable` 接口**
    *   **步骤**：
        1.  创建一个类，实现`java.lang.Runnable`接口。
        2.  实现接口中的`run()`方法。
        3.  创建该实现类的实例。
        4.  创建一个`Thread`对象，并将`Runnable`的实例作为构造参数传入。
        5.  调用`Thread`对象的`start()`方法。
    *   **示例**：
        ```java
        class MyRunnable implements Runnable {
            @Override
            public void run() {
                System.out.println("Runnable is running...");
            }
        }
        // 启动
        MyRunnable myRunnable = new MyRunnable();
        Thread t = new Thread(myRunnable);
        t.start();
        ```
    *   **优点**：
        *   **解耦**：将任务（`Runnable`）与线程的执行机制（`Thread`）分离。
        *   **灵活性**：类可以实现多个接口，避免了单继承的限制。
        *   **资源共享**：多个线程可以共享同一个`Runnable`实例，方便实现资源共享。
    *   **推荐方式**：通常推荐使用实现`Runnable`接口的方式来创建线程。

##### **10.4 线程同步：`synchronized`关键字**

当多个线程同时访问和修改共享资源（临界资源）时，可能会导致数据不一致，这就是**线程安全问题**。Java通过**同步机制**来解决这个问题，核心是**互斥锁**。

*   **`synchronized` 关键字**：是Java提供的内置锁机制，用于保证在同一时刻，只有一个线程可以执行被`synchronized`修饰的代码块或方法。

1.  **同步方法 (Synchronized Method)**
    *   **语法**：`public synchronized void methodName() { ... }`
    *   **锁定对象**：
        *   对于**非静态**同步方法，锁是**当前实例对象**（`this`）。
        *   对于**静态**同步方法，锁是**当前类的Class对象**（`ClassName.class`）。
    *   **行为**：一个线程进入同步方法时，会自动获取对应对象的锁。在方法执行完毕或抛出异常时，锁会自动释放。其他试图进入该对象**任何**同步方法的线程都将被阻塞，直到锁被释放。

2.  **同步代码块 (Synchronized Block)**
    *   **语法**：`synchronized (lockObject) { ... }`
    *   **锁定对象**：`lockObject`可以是任何对象引用。这提供了比同步方法更灵活的锁定机制，可以减小锁的粒度，提高并发性能。
    *   **行为**：线程执行到同步代码块时，必须先获取`lockObject`的锁。执行完毕后自动释放锁。

**死锁 (Deadlock)**：
当两个或多个线程互相持有对方所需要的锁，并无限期地等待对方释放锁时，就会发生死锁。例如，线程A持有锁1并请求锁2，而线程B持有锁2并请求锁1。

##### **10.5 线程通信：`wait()`, `notify()`, `notifyAll()`**

线程同步解决了互斥访问的问题，而线程通信则解决了线程之间的协作问题。

*   **机制**：Java的对象监视器（Monitor）机制提供了`wait()`, `notify()`, `notifyAll()`这三个方法，它们都定义在`java.lang.Object`类中。
*   **前提**：这些方法必须在**同步代码块或同步方法**中调用，即当前线程必须持有该对象的锁。

1.  **`wait()`**
    *   **作用**：使当前线程**释放**它所持有的对象锁，并进入该对象的**等待集 (Wait Set)**，进入`WAITING`或`TIMED_WAITING`状态。线程将一直在此等待，直到被其他线程唤醒。

2.  **`notify()`**
    *   **作用**：从该对象的等待集中**随机唤醒一个**正在等待的线程。被唤醒的线程并不会立即执行，而是进入该对象的**锁池 (Lock Pool)**，进入`BLOCKED`状态，重新竞争锁。只有当它再次获得锁之后，才能从`wait()`方法处继续执行。

3.  **`notifyAll()`**
    *   **作用**：唤醒该对象等待集中的**所有**线程，并将它们全部移入锁池。

**生产者-消费者模型**是线程通信的经典应用场景。

---

