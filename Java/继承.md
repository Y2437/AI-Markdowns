

这是一项重要的整理工作，系统性地掌握 Java 继承的所有细微之处，将帮助您真正理解面向对象的设计原则。

我将按照您的高要求，对 Java **继承（Inheritance）** 这一主题进行一次**全景式、极致细节**的深度整理。这份笔记将涵盖核心概念、复杂的初始化流程、关键关键字 `super` 的所有用法，并集成您现有的关于重写与隐藏的详细笔记。

---

## 📚 Java 继承 (Inheritance) 终极深度笔记

Java 继承是一种创建新类与已有类复用、扩展、组织关系的核心机制，它实现了 **代码复用** 和 **多态性**。

### 第一部分：继承的核心概念与基础约束

#### 1. `extends` 关键字与 Is-A 关系

*   **关键字：** 使用 `extends` 关键字，声明一个新类（子类/Subclass）继承自另一个已存在的类（父类/Parent Class 或 Super Class）。
*   **Is-A 原则：** 继承描述了一种“**是（Is-A）**”关系，即子类**是**父类的一种特殊类型。

#### 2. Java 继承的关键约束

| 约束类型 | 规则描述 | 深入解析 |
| :--- | :--- | :--- |
| **单继承** | Java **仅支持类的单继承**：一个子类只能直接继承一个父类。 | 这是为了避免 C++ 等语言中出现**“菱形问题（Diamond Problem）”**带来的复杂性（多继承中的方法冲突）。 |
| **多接口实现** | 虽然类只能单继承，但一个类可以**实现（implement）多个接口**，这被称为**多实现**。 | 接口提供了一种“契约式”的扩展和多态形式，不涉及代码实现的冲突。 |
| **特殊类** | **不可继承** `final` 类。 `final` 类设计上被定义为“不可再细化或改变”。 |
| **顶层类** | 所有的类，如果没有明确指定父类，都会**隐式地**继承自 `java.lang.Object` 类。 | `Object` 类是 Java 类体系的**最顶层基类**，包含了 `hashCode()`, `equals()`, `toString()`, `wait()`, `notify()` 等所有对象都具备的基础方法。 |

#### 3. 子类到底继承了什么？（可访问性与不可访问性）

| 成员类型 | 是否“继承”到子类 | 子类中是否“可访问” | 特别注意点 |
| :--- | :--- | :--- | :--- |
| **`public` / `protected` 成员**| 是 | 是 | 可被子类直接使用、重写、隐藏。 |
| **`(default)` 成员** | 是 | 否 (如果子类**不在同一包**) | 访问受包级限制，跨包继承时，默认成员不可访问。 |
| **`private` 成员** | 是（物理存在于内存） | 否 (不可见/不可访问) | 尽管 `private` 成员内存空间会分配给子类对象，但由于访问控制限制，子类**不能直接引用或调用**。访问只能通过父类提供的 `public/protected` 方法进行间接操作。 |
| **构造方法** | **否** | N/A | 构造方法永远不被继承，但父类的构造方法**必须被子类调用**。 |

---

### 第二部分：构造器与初始化流程 (Initializer Flow)

这是继承中最复杂的机制，用于保证对象创建的安全性与完整性。

#### 1. 父类构造器的隐式强制调用

*   **强制原则：** 创建一个子类对象时，**父类的构造方法必须被调用**。这是为了确保子类对象中父类部分的**状态被正确初始化**。
*   **隐式调用：** 如果子类构造方法中**没有显式**调用父类构造器，编译器会**自动**在子类构造方法的第一行插入一个对父类**无参构造方法**的调用：`super()`。
*   **显式调用：** 如果父类没有提供无参构造器，或者子类需要调用父类的有参构造器，子类必须**显式地**使用 `super(...)` 来指定。

#### 2. 构造器调用机制的严格限制

*   **第一行法则：** `this()`（调用当前类的其他构造器）和 `super(...)`（调用父类构造器）必须是构造方法中的**第一条语句**，且两者**只能存在一个**。

#### 3. 继承体系中完整的初始化执行顺序（从顶层 Object 开始）

一个对象被创建时，初始化过程是**自上而下**进行的，但执行流程却是**分步且穿插**的：

1.  **静态初始化（类加载阶段）：**
    *   执行 **父类** 的**静态代码块**和**静态成员变量**的赋值。（按它们在代码中的出现顺序执行）
    *   执行 **子类** 的**静态代码块**和**静态成员变量**的赋值。（按它们在代码中的出现顺序执行）
2.  **实例初始化（对象创建阶段）：** 从最顶层的基类开始，**沿着继承链自上而下**依次执行：
    *   执行 **父类** 实例初始化流程：
        1.  执行父类的**实例成员变量**的声明赋值语句。
        2.  执行父类的**实例代码块**。
        3.  执行父类中被调用的那个**构造方法**。
    *   执行 **子类** 实例初始化流程：
        1.  执行子类的**实例成员变量**的声明赋值语句。
        2.  执行子类的**实例代码块**。
        3.  执行子类中自身的逻辑（在 `super()` 或 `this()` 之后的部分）。

---

### 第三部分：核心机制：重写 (Overriding) 与 隐藏 (Hiding)
## ✨ Java 继承中 **重写 (Overriding)** 与 **隐藏 (Hiding)** **极致** 深度解析

该笔记将从原理、规则、特殊案例和约束等方面，全面深入地解析 Java 实例方法重写（Overriding）与静态方法隐藏（Hiding）的区别。

### 一、实例方法重写 (Method Overriding)：多态之源

方法重写只适用于**非 `static` 的实例方法**，是 Java **多态性（Polymorphism）** 实现的基础。

#### A. 核心原理：动态绑定 (Dynamic Dispatch)

*   **JVM机制：** 编译器（在编译阶段）仅检查引用的**编译时类型**是否包含该方法。
*   **运行时调用： JVM在执行时（运行时），通过查找对象的实际类型（由堆中对象决定，而不是引用变量类型），调用最适合该实际类型的重写方法版本。这一过程通过虚方法表 (V-Table) 等机制完成**
*   **总结：** 调用哪个方法，看**堆**中的**实际对象**。

#### B. 重写的必要条件与**极度严格的约束**

| 约束维度 | 规则描述 | 特殊限制或细节补充 |
| :--- | :--- | :--- |
| **方法签名** | 必须 **完全相同**：方法名、参数类型、参数个数、参数顺序。 | `final` 修饰的方法无法重写。 `private` 方法无法被重写，子类定义同名方法视为一个**新方法**。 |
| **返回类型** | 子类方法返回类型可以是父类方法返回类型的**子类（协变返回）**。 | 如果父类方法返回 `void`，子类必须返回 `void`。 |
| **访问权限** | 子类的权限 **不能严于** 父类，但可以更宽松。 | 规则：`public > protected > default > private`。 例如：父类 `protected`，子类可以是 `protected` 或 `public`，但**不能是 `default` 或 `private`**。 |
| **异常类型** | 抛出的**受检异常**（Checked Exception）范围不能 **大于** 父类。 | 1. 父类方法**没有**抛出受检异常，子类**不能**抛出受检异常。 2. 父类方法抛出 A 异常，子类可以抛出 A 的**子类异常**，或者**不抛出**任何异常。 3. 对于**非受检异常**（运行时异常），无此限制。 |
| **修饰符组合** | **× 限制组合：** 重写方法**禁止**添加 `static` 修饰符（否则是编译错误，即禁止实例方法重写为静态方法）。 | - **`synchronized`：** 父子类中，方法是否添加 `synchronized` 修饰符**不影响重写规则**，这是线程特性，而非签名或访问权限。 - **`native` / `abstract`：** 重写时子类可以移除或添加这些修饰符（遵守一般规则，如非抽象子类不能保留抽象方法）。 |
| **构造方法** | **绝对不能**重写。 | 构造方法不是方法，它的作用是初始化对象，且没有返回值。 |

---

### 二、静态方法隐藏 (Method Hiding)：编译时遮蔽

方法隐藏只适用于 **`static` 的静态方法**。它与实例方法的重写工作原理完全不同，与多态性无关。

#### A. 核心原理：静态绑定 (Static Binding) / 早期绑定

*   **编译时决定：** 编译器（在编译阶段）就已经**根据引用的类型**来决定要调用哪一个方法。
*   **运行时调用：** 在程序执行时，无论该引用实际指向堆内存中的哪个子类对象，**都不会影响**调用的方法版本。子类的同名方法仅仅是**隐藏/遮蔽（Shadow）** 了父类的方法。
*   **总结：** 调用哪个方法，看**栈**中的**引用变量类型**。

#### B. 隐藏的必要条件与约束

| 约束维度 | 规则描述 | 特殊限制或细节补充 |
| :--- | :--- | :--- |
| **静态一致性** | **核心约束：** 父子类中必须都是 `static` 方法，否则是**编译错误**。 | **不可混用：** 试图用静态方法去**重写**实例方法，或用实例方法去**隐藏**静态方法，都是编译错误。 |
| **访问权限** | 遵循与重写相似的规则：权限 **不能严于** 被隐藏的父类方法。 | - |
| **绑定机制** | **不受多态影响：** 无论引用指向什么对象，`Parent P = new Child(); P.staticMethod();` 总是执行 `Parent` 版本的方法。 | 鼓励**通过类名**访问静态方法 (`Parent.staticMethod()`) 以清晰地表示静态调用，避免引起方法隐藏的歧义。 |
| **特殊性** | 方法隐藏并**没有**特殊的 `JVM` 指令（如实例方法的 `invokevirtual`），而是由编译器在编译时直接将方法调用绑定到所属类型上。 | - |

---

### 三、附加与延伸：成员变量的覆盖 (Field Shadowing)

为了笔记的完整性，这里加入与方法重写/隐藏相似但作用于数据的概念。

#### A. 核心原理：数据覆盖 / 遮蔽

*   **定义：** 当子类中声明了与父类**同名**的成员变量（不论类型是否一致、访问权限是否一致），子类的变量就会**覆盖**或**遮蔽**（Shadow）掉父类的变量。
*   **作用机制：** 成员变量的访问机制与静态方法相似，是纯粹的**静态绑定/编译时行为**。
    *   通过父类引用访问同名变量：访问父类的变量。
    *   通过子类引用访问同名变量：访问子类的变量。

#### B. 核心差异

| 特征 | 方法重写 (实例方法) | 成员变量 (字段) |
| :--- | :--- | :--- |
| **访问原理** | 动态多态，看**运行时对象类型**。 | 静态绑定，看**编译时引用类型**。 |
| **可达性** | 通过 `super.method()` 可以强制调用父类未重写版本（如果未重写为 `final`）。 | 通过 `super.variableName` 可以强制访问父类被遮蔽的变量。 |

---

### 四、速记对比表格

| 特性 | **方法重写 (Overriding)** | **方法隐藏 (Hiding)** | **变量覆盖 (Shadowing)** |
| :--- | :--- | :--- | :--- |
| **影响目标** | 实例方法（非 `static`） | 静态方法（`static`） | 成员变量 (Field) |
| **发生机制** | **多态 (Polymorphism)** | **静态绑定** | **静态绑定** |
| **绑定时机** | **运行时 (Runtime)** | **编译时 (Compile Time)** | **编译时 (Compile Time)** |
| **使用注解** | ✔ 可以使用 `@Override` 检查（强烈推荐） | ❌ **不能**使用 `@Override` | N/A |
| **`final` 影响** | `final` 方法 **禁止** 被重写。 | `final` 静态方法 **可以** 被隐藏。 | `final` 变量 **可以** 被覆盖。 |
| **关键词** | **invokevirtual** 指令（JVM） | 引用声明类型**优先** | 引用声明类型**优先** |

### 第四部分：关键关键字 `super` 的精细用法

`super` 关键字专门用于在子类中访问其父类的成员，是处理重写与隐藏机制的关键工具。

| `super` 用法 | 目的与约束 | 深度细节与时机 |
| :--- | :--- | :--- |
| **`super()` / `super(args)`** | 调用父类的**构造方法**。 | **绝对必须是**子类构造方法内的**第一行**语句。 用于保证父类对象实例的部分被正确初始化。 |
| **`super.methodName(...)`** | 显式调用父类中**被子类重写**或**被子类隐藏**的方法。 | 当子类想在自己的方法中重用父类的逻辑，而非重新实现时使用。 它允许绕过子类的重写版本，强制调用父类的方法体。 |
| **`super.variableName`** | 显式访问父类中**被子类覆盖**的同名成员变量。 | 用于处理变量遮蔽（Shadowing）的问题，确保访问到父类的那份数据。 访问哪一个成员变量**总是在编译时确定**。 |

---

### 第五部分：抽象类 (Abstract Class) 与 接口 (Interface) 的继承

抽象类和接口虽然都可以被继承和实现，但它们的约束条件不同，代表了不同层面的继承。

| 特征 | **抽象类 (Abstract Class)** | **接口 (Interface)** |
| :--- | :--- | :--- |
| **关系关键字** | `extends` | `implements` |
| **继承数量** | **单继承** | **多实现** (可实现多个接口) |
| **构造器** | **有构造器**（用于初始化父类数据），但不能被直接 `new` 实例化。 | **无构造器**。 |
| **成员限制** | 可以包含抽象方法、非抽象方法、构造器、各种类型的变量。 | 1. 实例方法默认 **`public abstract`**（Java 8 之前）。 2. 变量默认 **`public static final`**（即常量）。 3. **Java 8 之后**可包含 `default` 和 `static` 方法体。 |
| **子类责任** | 非抽象子类**必须**实现父类中**所有**抽象方法。 | 实现类**必须**实现接口中**所有**抽象方法。 |

